{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/01/27/os-greedy-algorithms.html","result":{"data":{"markdownRemark":{"html":"<p>Quando estive revisando a disciplina de <a href=\"/tag/algoritmos.html\" title=\"Leia mais sobre Algoritmos\">algoritmos</a>, me deparei com os tais \"algoritmos gulosos\", ou <em>greedy algorithms</em>. Lembro que na época eu automaticamente associei o termo a soluções de baixa utilidade ou performance. Mal sabia eu que estive equivocado esse tempo todo.</p>\n<p>Os <em>greedy algorithms</em> são fundamentais nos estudos de algoritmos e otimizações, não à toa o mundo acadêmico faz questão de mencioná-los em uma variedade de cursos de algoritmos ou de computação. Mas algumas definições podem passar uma ideia equivocada sobre o que eles realmente são, e do que são capazes.</p>\n<h2>Definição</h2>\n<p>Embora a <em>Wikipedia</em> possua uma definição interessante sobre o assunto, foi no <em>GeeksforGeeks</em> que <a href=\"https://www.geeksforgeeks.org/greedy-algorithms/\" title=\"Greedy Algorithms\">encontrei uma passagem bem esclarecedora</a>:</p>\n<blockquote>\n<p>Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. So the problems where choosing locally optimal also leads to global solution are best fit for Greedy.</p>\n</blockquote>\n<p>O <em>Paulo Feofiloff</em> vai além em <a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/guloso.html\" title=\"USP - Algoritmos gulosos\">\"Algoritmos gulosos\"</a>:</p>\n<blockquote>\n<p>Para resolver um problema, um algoritmo guloso escolhe, em cada iteração, o objeto mais apetitoso que vê pela frente. (...) Um algoritmo guloso é míope: ele toma decisões com base nas informações disponíveis na iteração corrente, sem olhar as consequências que essas decisões terão no futuro. Um algoritmo guloso jamais se arrepende ou volta atrás: as escolhas que faz em cada iteração são definitivas.</p>\n</blockquote>\n<p>A estratégia gulosa tem por abordagem encontrar a melhor resposta para cada passo, sem se importar em resolver esse passo novamente ou com os passos seguintes, esperando como consequência um resultado global ótimo. Acabamos por ter algoritmos mais simples e intuitivos em grande parte dos casos, mas não necessariamente apresentando a melhor resposta.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1e0c9882d38789417728440a6de772b3/acb04/greedy-boo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAADAgT/2gAMAwEAAhADEAAAAUq1Q65xaay//8QAGhABAAIDAQAAAAAAAAAAAAAAAQASAgMhIv/aAAgBAQABBQLDH1sCvJUsBNgD/8QAGREAAwADAAAAAAAAAAAAAAAAAAECERNh/9oACAEDAQE/AZhJYNHT/8QAGhEAAQUBAAAAAAAAAAAAAAAAAAECAwQicf/aAAgBAgEBPwF9jXBJD//EABoQAQACAwEAAAAAAAAAAAAAAAEAERASITH/2gAIAQEABj8CLlpjauxIUHk//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAERITFBYVH/2gAIAQEAAT8hW9VlS68LYHxFKSZBTiRCILg//9oADAMBAAIAAwAAABAwP//EABcRAQEBAQAAAAAAAAAAAAAAAAEAQVH/2gAIAQMBAT8QX9Scn//EABgRAAMBAQAAAAAAAAAAAAAAAAABEUGx/9oACAECAQE/EHU5jpRWH//EABwQAQEBAAMAAwAAAAAAAAAAAAERACFBUTFhgf/aAAgBAQABPxAHMb4e/rATBEPPWqKgLwLqsvwhlMq4PNtuGKBCPXf/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"&quot;Imagem do Majin Boo, personagem de Dragon Ball Z&quot;\"\n        title=\"Algoritmos gulosos são como o Maijin Boo. Gulosos em essência, mas nem por isso não eficazes (tvovermind.com)\"\n        src=\"/static/1e0c9882d38789417728440a6de772b3/acb04/greedy-boo.jpg\"\n        srcset=\"/static/1e0c9882d38789417728440a6de772b3/7809d/greedy-boo.jpg 192w,\n/static/1e0c9882d38789417728440a6de772b3/4ecad/greedy-boo.jpg 384w,\n/static/1e0c9882d38789417728440a6de772b3/acb04/greedy-boo.jpg 750w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Algoritmos gulosos são como o Maijin Boo. Gulosos em essência, mas nem por isso não eficazes (tvovermind.com)</figcaption>\n  </figure></p>\n<p>As propriedades desse paradigma podem lembrar outras formas de escrever algoritmos, portanto, é importante saber diferenciá-lo.</p>\n<h3>Greedy não é brute-force</h3>\n<p>É bom deixar claro que um algoritmo guloso não é um algoritmo de força bruta:</p>\n<ul>\n<li><em>Greedy</em> significa que o algoritmo, a cada passo, seleciona a melhor opção para aquele passo;</li>\n<li><em>Brute-force</em> significa que o algoritmo seleciona uma opção de uma maneira mais simples, óbvia ou direta. E que repete essa tentativa até encontrar o resultado esperado.</li>\n</ul>\n<h3>Greedy não é naive</h3>\n<p>Essa talvez tenha sido a origem da minha confusão. <em>Naive algorithms</em> são de certa forma o primeiro passo para quando você está tentando resolver um problema complexo: Primeiro faça funcionar, depois faça melhor.</p>\n<p>Em uma abordagem <em>naive</em>, não estamos necessariamente tentando resolver cada passo com a melhor opção possível, e sim tentando resolver o todo de maneira ingênua, sem nenhuma estrutura de dados rebuscada ou cálculo preparatório, e sem se preocupar com a performance do algoritmo em si.</p>\n<h3>Naive vs. Brute-force vs. Greedy</h3>\n<p>Uma maneira mais interessante de compreender como escrevemos um algoritmo com essas diferentes práticas é através do <a href=\"https://en.wikipedia.org/wiki/Knapsack_problem\" title=\"Leia o artigo na Wikipedia\"><em>Knapsack Problem</em></a>. Nesse famoso problema temos um conjunto de itens, cada qual com seu determinado <code class=\"language-text\">peso</code> e <code class=\"language-text\">valor</code>, e temos por desafio colocar o maior valor possível dentro de uma mochila com um determinado limite de peso.</p>\n<ul>\n<li>Um exemplo do método <em>naive</em> seria pegarmos os itens mais leves e colocarmos na bolsa até não haver mais espaço;</li>\n<li>Com <em>brute-force</em>, testaríamos todas as combinações de itens até chegar ao valor máximo para o limite de peso da bolsa;</li>\n<li>Já com o paradigma <em>greedy</em>, por intuição, pegaríamos primeiro os itens mais valiosos, até atingirmos o peso total da bolsa.</li>\n</ul>\n<p>Todas as três formas chegam a um resultado. É possível afirmar que a primeira e última opção terão performance semelhantes, mas não necessariamente chegarão a um resultado ótimo. Encontrar o melhor resultado através da forma bruta, nesse problema, não é a melhor solução.</p>\n<h2>Qual o melhor uso de greedy algorithms?</h2>\n<p>Segundo o <em>Brilliant.org</em>, se as propriedades abaixo forem verdadeiras, pode-se aplicar a abordagem <em>greedy</em> para resolução do problema:</p>\n<ul>\n<li>Uma solução global ótima pode ser atingida ao escolher a opção ótima de cada passo;</li>\n<li>Um problema tem uma subestrutura ótima se uma solução ótima para o problema global conter as soluções ótimas para os sub-problemas.</li>\n</ul>\n<p>Em outras palavras:</p>\n<blockquote>\n<p>(...) greedy algorithms work on problems for which it is true that, at every step, there is a choice that is optimal for the problem up to that step, and after the last step, the algorithm produces the optimal solution of the complete problem.</p>\n</blockquote>\n<p>Algoritmos como <a href=\"https://brilliant.org/wiki/huffman-encoding/\" title=\"Leia mais no Brilliant\"><em>Huffman Code</em></a> e <a href=\"https://brilliant.org/wiki/dijkstras-short-path-finder/\" title=\"Leia mais no Brilliant\"><em>Dijkstra's Shortest Path</em></a> são <em>greedy algorithms</em> famosos que cumprem muito bem o seu papel. O <em>GeeksforGeeks</em> lista <a href=\"https://www.geeksforgeeks.org/greedy-algorithms/\" title=\"Leia mais no GeeksforGeeks\">uma porção de outros algoritmos e problemas que utilizam o paradigma com sucesso</a>. Um muito comum em entrevistas de emprego é o <a href=\"https://www.geeksforgeeks.org/minimum-swaps-bracket-balancing/\" title=\"Leia no GeeksforGeeks\"><em>Minimum Swaps for Bracket Balancing</em></a>.</p>\n<h2>Considerações finais</h2>\n<p>Compreendendo a diferença entre um <em>greedy</em> e um <em>naive algorithm</em>, fica mais fácil entender quando utilizar uma técnica ou outra. Uma abordagem ingênua funciona bem quando estamos começando a construir o algoritmo que solucionará um problema. De forma iterativa podemos melhorá-lo, até chegar aos valores de performance desejados.</p>\n<p>Uma abordagem <em>greedy</em> pode trazer resultados satisfatórios para a sua solução, mas nem sempre trará o melhor resultado. Caso as propriedades listadas acima se apliquem ao algoritmo que você procura, sem dúvida nenhuma é uma técnica que, além de lhe ajudar a escrever um solução mais intuitiva, te trará os resultados esperados.</p>\n<p>Se você ficou curioso sobre como resolver o <em>Knapsack Problem</em> de forma ótima, há a opção de utilizar <em>Dynamic Programming</em>, outro paradigma que tem certa semelhança com <em>greedy algorithms</em>, e que vamos falar sobre em outro <em>post</em>. Uma alternativa mais simples e intuitiva (e <em>greedy</em>) é criar uma terceira variável que armazene <code class=\"language-text\">peso / valor</code> e utilize esse valor no processo de ordenação (<a href=\"https://github.com/kplaube/rosetta-lua/blob/master/rosetta/lib/knapsack.lua\" title=\"Veja a resolução do problema em Lua\">exemplo</a>).</p>\n<p>Até a próxima.</p>\n<h2>Referências</h2>\n<ul>\n<li><a href=\"https://brilliant.org/wiki/greedy-algorithm/\">Brilliant - Greedy algorithms</a></li>\n<li><a href=\"https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-c++/html/page441.html\">Data Structures and Algorithms with Object-Oriented Design Patterns in C++ - Brute-Force and Greedy Algorithms</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/greedy-algorithms/\">GeeksforGeeks - Greedy algorithms</a></li>\n<li><a href=\"https://smart--grid.net/cours-lessons-theory/algorithm/brute-force-naive-greedy-algorithm/\">Smart Grid - Brute Force/Naive/Greedy algorithm</a></li>\n<li><a href=\"https://stackoverflow.com/questions/47238823/why-selection-sort-is-not-greedy\">Stackoverflow - Why selection sort is not greedy?</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/guloso.html\">USP - Algoritmos gulosos</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Greedy_algorithm\">Wikipedia - Greedy algorithm</a></li>\n</ul>","excerpt":"Quando estive revisando a disciplina de algoritmos, me deparei com os tais \"algoritmos gulosos\", ou greedy algorithms. Lembro que na época…","frontmatter":{"date":"2019-01-27T15:28:00.000Z","title":"Os greedy algorithms","tags":["estrutura-de-dados","algoritmos"],"thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACoUlEQVQ4y5VUSU8UQRj9PHjzZkz04smTJ68m/gETDyaePBkTD8aD+0G9eHOJJAKuIJgoRBFDokYlonEBVDCOM8OAAzOObMMMMDh7z9Jd3c+qoqvpaQeIL6l099dVr973vq+KUAeWZckhYPKnYVpgYtgxPsP57wWtRqjIvFCx/yJ0L8xVGU5/TWJv7xRezeRX3WhdhSq9w5/ioOs/QDcDoNYQAktlGWdW/bRpLf907tuOrgnQnSA23R8D3QigJZx2/q1LaLm8EQsELvsXQU1+SbatM4xU2XDStuqoJK8qy66qwGS+ilau6EEkg7NDSXRGs+idLdQotDxFIm+LuHc88HYGg/MaEpqOptCSjO17Mw1fquTMZy5CMUitNz2tIhQpv4YXNJzklRaIZCtyo4WSUbeFyE0SzVWx58VvbOVeHf+SkLGpgo7dz2LY/PAn3sWLMvYklsWWjjB2Po3gtd1KbEXhimcnOIlskWY/9vdNy9gZrpQal9tGEAs0BFNyjhi7eqI1dtUQPv6VBd0dAd0O4ty3eRl7PpXnbTMiF6vYy2keawmBbgVxyrbCUej1oH0ig/bxNPqTRWfy8GIJXTxNd4eIYl3yp1BhZm2VFbvAh0QRjbyaHdEMujmBID34fhZZfvwEqmw5G5XRRd8ChnjBVk35SiCFvngBSc3Akf45GRtLVyTpQFJz1DF7fncsh+bRP/JdcZBS18bT3HAvJP0ROPQxzlNalO/pCpNtc557KHxW6Ylqb2wbRc9kzvGRFPOxwTnQNZ88GQLbH42DGnz4PL+sTKiWR5AXYraoOxnR1e+4YBdLcJHaraCb0mh1hptHl3B0YA5F3XRSbRhJSRKFsmFK3zVjpTBU77Jc73utOeQ+3Mx1JTG7WN7/zPz3InF//wXTSsgPceG2xAAAAABJRU5ErkJggg==","width":180,"height":180,"src":"/static/4a2df913e886355bb29650f9d97a864c/d8216/algoritmos-3.png","srcSet":"/static/4a2df913e886355bb29650f9d97a864c/d8216/algoritmos-3.png 1x"}},"publicURL":"/static/4a2df913e886355bb29650f9d97a864c/algoritmos-3.png"}},"fields":{"readingTime":{"minutes":5.295},"slug":"/2019/01/27/os-greedy-algorithms.html"}},"site":{"siteMetadata":{"author":{"name":"Klaus Peter Laube","gravatar":"https://en.gravatar.com/userimage/12163112/d3ae0c6239980b01ff1f1730b65c2ebe.jpg"},"siteUrl":"https://klauslaube.com.br"}}},"pageContext":{"slug":"/2019/01/27/os-greedy-algorithms.html"}},"staticQueryHashes":["2831923220","4114525740"]}