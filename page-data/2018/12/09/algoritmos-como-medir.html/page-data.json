{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018/12/09/algoritmos-como-medir.html","result":{"data":{"markdownRemark":{"html":"<p>No <a href=\"/2018/11/09/analise-assintotica.html\" title=\"Leia mais sobre Análise Assintótica\"><em>post</em> anterior</a>,\nintroduzimos o conceito de Análise Assintótica e falamos brevemente sobre\no <em>Big O Notation</em>. Nesse <em>post</em>, vamos pincelar sobre como mensurar um algoritmo\nutilizando a notação.</p>\n<p>Mas antes de mais nada é preciso reforçar: O <em>Big O</em> é apenas uma das métricas\n(número de passos proporcional ao tamanho do seu <em>input</em>) que pode te levar à\nconclusão de que o seu algoritmo é eficiente ou não. Em momento de implementação,\noutras métricas como memória, tempo, acesso a recursos e consumo de energia podem\nimpactar nesse resultado.</p>\n<p>Para tanto, é comum termos duas formas distintas de análise:</p>\n<ul>\n<li><strong>Empírica:</strong> Tempo de execução do código, implementado na linguagem de programação de sua escolha.</li>\n<li><strong>Analítica:</strong> Não leva em consideração o ambiente no qual o seu algoritmo irá executar, representando através de uma ordem de grandeza o tempo de execução do algoritmo.</li>\n</ul>\n<p>Vamos focar no método analítico, claro. Se você está interessado no método\nempírico, ferramentas de <em>profiling</em> podem te dar ótimas dicas sobre a performance\nda sua solução.</p>\n<h2>Tempo x Espaço</h2>\n<p>É possível utilizar o <em>Big O</em> para medirmos quanto de espaço que um determinado\nalgoritmo ocupa. Na <em>Wikipedia</em> existe inúmeros <em>wikis</em> sobre algoritmos famosos,\ne grande parte deles apresenta a seguinte estrutura:</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 331px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/62eb53a45bf4c117b6f46315dddc2398/62452/wikipedia-merge-sort.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 155.20833333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAAAsSAAALEgHS3X78AAAEK0lEQVRIx71V23LaSBD1//9FvHZclf2EfYvtBC+IiwDdkISExFUYkBDiztnuFijEZW9VKlurqsOgme4zZ7p7Wjd47zmdZBgEHl5eSmi3WvA8H2qzidlsjn97bnb7PTbbHbZX2Gy2OByOCHsenr59w+PjE5otDeWKgih6Re6z/dmHwPM32XojzofD4QpH7Gl8Vzxhf7Z567PK1rhZk5qPnhMd/Xg8Cvj/icac8v2HxRWE4vBb+IDwVx/xYV/8n4S/etwPCX8nlvivjnx99HcVck3Zto1yuYxKpYLKeVQIVUX5aY5Rq9WosHOO7LoOC9lZhufnZ9zf3+Ph82cZPxNuP33C3d0d/ri9Ffz55QseHh5kLV0uxbco7LdHTdMU8/kcSZIgjmMsFgsBz13+X8A2fKriyNl6jf5gCNtx0Wrr0A1LGoHnedB1E27Xl/UwDCgUDr17cB0HNo0+2XS9AJ2Og144zAlZJl/80vcSqtUGNE1Dl0i0dj5Xpw7j2B001DYMs4OKUqO4NdAiuyqPJKKiVIjD+EG4WmW0i507GQYs00CtrqJNxm1Nh2VZpNaASYQ6vTdVFQ3aSDdsImzDcT2kq3UeQ25V09epGGhaR3pevaGKClVtyQYakXFIGo0mWq02NOqPDVrjkDSI3CQxU+qTopD7WNgf0G4G+v0R+mFfYjaeTCWWjsRWow1UIfX9gOLJNmNZD8IQXZobkX1x5N0+73176YOn83iUuUWc0GYmKdORbXZFT7zuj0f6OdCPHDlJlnj6+oTy34osXgxYOZcUb3YhcMM56toIemeCcnOIsjqAakZiy8gJlwlVfPkcfBuGrqNju9ju9tLSt7udtHvGMErR8eeIlxuk2VaQrbf5J4Tsz4QpKjUKNGVMNx0iNqFbDmZxhmS1wZLATkweDl9huhGSNKPvzkZILuoKwkWSoW4toNoLtJ0FFGOOJo3l9hjl1hjP9REsUsWfgV4voKJ2YVICw8EIHGWOHZMVhHGywmONYmFFULQxkUeoahPUTX6foGFNEacb+TBF0xmGowmm01dMJhGG4wmGw5HEuiDkgvSHCfqTJcJRgmC8xIBiNZqmCOh9QPMcKyb0SaHjeFJKvt+DYXVgUQ1yuXDy3nz1Th/geE7QgY4cohf06Va5crMc15dk2k6PbA4/FHr9GF2CP0hkdIIFPFLdDWNMZivszhkPiKzr9c4F3adsp3ilG5IsV9cxzKDoEUqUgBcC/292plAJDSOSEDDZjhT0glCObJM6jiWrYuWMgnAer1BSR6hRErhIFT1PyPfmSErmdDpQ0HfixOpct4tms0XHdKTTDMeR3KqisDnLrOxrdYC/SiFqRLha50UrNXYuiT0RcjIU/gwodXHmjS41WChcZRuwSsaMsFhmkrU1gdekvRF4LqZrOl/Ecr/5/YJrm38AGoEoxF2sMwoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"&quot;Exemplo de card do Wikipedia mostrando os tempos de um algoritmo&quot;\"\n        title=\"Exemplo de card do Wikipedia mostrando os tempos de um algoritmo (wikipedia)\"\n        src=\"/static/62eb53a45bf4c117b6f46315dddc2398/62452/wikipedia-merge-sort.png\"\n        srcset=\"/static/62eb53a45bf4c117b6f46315dddc2398/8514f/wikipedia-merge-sort.png 192w,\n/static/62eb53a45bf4c117b6f46315dddc2398/62452/wikipedia-merge-sort.png 331w\"\n        sizes=\"(max-width: 331px) 100vw, 331px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Exemplo de card do Wikipedia mostrando os tempos de um algoritmo (wikipedia)</figcaption>\n  </figure></p>\n<p>O <em>Merge sort</em>, um dos mais famosos algoritmos de ordenação, além de ter\numa performance média de <code class=\"language-text\">O (n log n)</code>, em seu pior cenário ocupa\n<code class=\"language-text\">O(n)</code> de espaço. Onde <code class=\"language-text\">n</code> corresponde ao tamanho da entrada do algoritmo.\nLogo, se você passar um <em>array</em> de 10 posições para o <em>Merge sort</em> ordenar,\nele ocupará outras 10 posições ao fim do processo.</p>\n<p>Em contrapartida, o <em>Bubble sort</em>, também famoso mas nada performático\n(<code class=\"language-text\">O(n²)</code>), ocupa <code class=\"language-text\">O(1)</code> (não necessitando de novas posições na memória\npara fazer a ordenação).</p>\n<p>Se você estiver projetando a sua solução para um ambiente limitado,\nserá necessário levar em consideração o espaço, mas é muito comum nos tempos\natuais <a href=\"/2012/05/14/o-cache-e-o-http.html\" title=\"O Cache e o HTTP\">sacrificarmos memória em prol do tempo de execução</a>.</p>\n<h2>Quanto mais próximo de linear, melhor</h2>\n<p>Voltando o foco ao tempo de execução, é possível categorizarmos um bom algoritmo\nquando ele é o mais próximo possível de linear (se ele for sublinear ou constante,\nmelhor ainda). Ou seja:</p>\n<ul>\n<li>Se ordernar <strong>10 items</strong> leva <strong>1 milissegundo</strong>;</li>\n<li>Ordenar <strong>20 items</strong> deveria levar <strong>2 milissegundos</strong>;</li>\n<li>E ordenar <strong>100 items</strong> deveria levar <strong>10 milissegundos</strong>.</li>\n</ul>\n<p>Esse comportamento é linear, resultando em <code class=\"language-text\">O(n)</code>. Mas o comportamento abaixo\nnão é o dos melhores:</p>\n<ul>\n<li>Se ordenar <strong>10 items</strong> leva <strong>1 milissegundo</strong>;</li>\n<li>E ordenar <strong>20 items</strong> leva <strong>4 milissegundos</strong>;</li>\n<li>E ordenar <strong>100 items</strong> leva <strong>100 milissegundos</strong>;</li>\n<li>Temos uma progressão quadrática, resultando em <code class=\"language-text\">O(n²)</code>.</li>\n</ul>\n<p>Algo não tão desejável em se tratando de algoritmos.</p>\n<h2>Mais um pouquinho de teoria</h2>\n<p>Vamos gastar um pouco de teoria aqui para definir <em>Big O</em>:</p>\n<blockquote>\n<p>Se um tempo de execução é O(f(n)), então para um n suficientemente grande,\no tempo de execução é no máximo k*f(n) para alguma constante k.</p>\n</blockquote>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 399px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/24b310c5f126c92446525b33d67bd13c/a307d/big-o.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.895833333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABcSAAAXEgFnn9JSAAABJElEQVQoz42T226DMAyGef835KZC3IxK0zYgCTnZ/+xQOqChWiQrjmL+fD7QMDPUdG37trbjPmZbORO895imCSmlZ1yjB73YC9aEdE+JJZbgnJhNmGeDYRgQQjgKLstyEuQXwVUoIwYCHWFLTM65+FXCmm+FapcvkkB0XYe2bXG73dD3fT3lPRUJirMZVixFAkscuaUYP4jOpG8FNc0YGcrGEkfOgYkOAucyXaasdbImgWMUsQiyrlrbs39oShHKayeNkQZMFiwdJB+eZO/G7I8wrIR+dBjvo+xmTe8xX+XjU0muKJss6ZifGfbbI5iArCR6WXm9ts6Ujc7P58cXotSIKJf0dVCTjoYQXlmU2qq9EKoTQpS0Q2nOf0wf1If3P8Qm+Au3VLMLZhCDPgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"&quot;f(n) e Big O&quot;\"\n        title=\"f(n) e Big O (khanacademy.org)\"\n        src=\"/static/24b310c5f126c92446525b33d67bd13c/a307d/big-o.png\"\n        srcset=\"/static/24b310c5f126c92446525b33d67bd13c/8514f/big-o.png 192w,\n/static/24b310c5f126c92446525b33d67bd13c/804b2/big-o.png 384w,\n/static/24b310c5f126c92446525b33d67bd13c/a307d/big-o.png 399w\"\n        sizes=\"(max-width: 399px) 100vw, 399px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">f(n) e Big O (khanacademy.org)</figcaption>\n  </figure></p>\n<p>Dizemos que o tempo de execução é <code class=\"language-text\">big-O de f(n)</code> ou só <code class=\"language-text\">O de f(n)</code>. Com\nisso informamos limites assintóticos superiores, ou seja, que no pior cenário\no tempo de execução cresce de uma maneira até atingir determinado limite, mas\npoderia crescer mais devagar. Não podemos desconsiderar que o <em>input</em> tem que ser\nsuficientemente grande (repare na linha pontilhada). Não é incomum vermos\nalgoritmos que performem em <code class=\"language-text\">O(n log n)</code> tendo um desempenho ruim com um\nconjunto de dados pequeno.</p>\n<h2>Agora sim! Vamos contar</h2>\n<h3>Complexidade constante: O(1)</h3>\n<p>Queremos calcular qual é a complexidade de um algoritmo de troca de valores:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    temp_num <span class=\"token operator\">=</span> num1\n    num1 <span class=\"token operator\">=</span> num2\n    num2 <span class=\"token operator\">=</span> temp_num</code></pre></div>\n<p>Podemos, em teoria, contar cada atribuição de valor executada pelo algoritmo\ncomo um “passo”. Teríamos <code class=\"language-text\">complexidade = 3</code>, e esse resultado nunca mudará,\nnão importa qual valor que passe de entrada. Logo, é possível dizer que a\ncomplexidade desse algoritmo é constante, representada por <code class=\"language-text\">O(1)</code>.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fc9d05e0486545742dfa74774d00ba18/c08c5/social-network-algorithm.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAID/9oADAMBAAIQAxAAAAGTWkMlMmJN/wD/xAAcEAABAwUAAAAAAAAAAAAAAAAAAQMyAgQSMUP/2gAIAQEAAQUCmMPUYyOdsLv/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEn/8QAFREBAQAAAAAAAAAAAAAAAAAAAhD/2gAIAQIBAT8BU//EABkQAAMAAwAAAAAAAAAAAAAAAAABERIgUf/aAAgBAQAGPwLJnIV6f//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExcUFh/9oACAEBAAE/Idk+0URLHM4N3Fso2zx8IMvGJFTP/9oADAMBAAIAAwAAABDE3//EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxC2yn//xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8QAFl//8QAHBABAQADAAMBAAAAAAAAAAAAAREAITFBYXGR/9oACAEBAAE/ENwEvB8AMflgT2+saqC95gV3yT9wGgbphMkt23P/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"&quot;Eduardo Saverin, personagem do file The Social Network, rabiscando algoritmo na janela&quot;\"\n        title=\"Em um piscar de olhos, você estará rabiscando algoritmos nas janelas da sua casa (blogossus.com)\"\n        src=\"/static/fc9d05e0486545742dfa74774d00ba18/c08c5/social-network-algorithm.jpg\"\n        srcset=\"/static/fc9d05e0486545742dfa74774d00ba18/7809d/social-network-algorithm.jpg 192w,\n/static/fc9d05e0486545742dfa74774d00ba18/4ecad/social-network-algorithm.jpg 384w,\n/static/fc9d05e0486545742dfa74774d00ba18/c08c5/social-network-algorithm.jpg 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">Em um piscar de olhos, você estará rabiscando algoritmos nas janelas da sua casa (blogossus.com)</figcaption>\n  </figure></p>\n<p>Pode parecer confuso não utilizar <code class=\"language-text\">O(3)</code>, mas seguindo a definição matemática\napresentada anteriormente, quando eu assumo que meu algoritmo tem\ncomplexidade <code class=\"language-text\">O(1)</code>, estou dizendo que o seu limite assintótico superior é menor\nou igual a <code class=\"language-text\">k * f(n)</code>. Se considerarmos o <code class=\"language-text\">k</code> como constante representando a\nquantidade de atribuições do nosso algoritmo <code class=\"language-text\">(3)</code> e <code class=\"language-text\">f(n)</code> como o\n<em>running time</em> <code class=\"language-text\">(1)</code>, temos como <em>upper bound</em> o valor <code class=\"language-text\">3</code>.</p>\n<p>Em outras palavras: Se o tempo de execução do seu algoritmo é constante, a\nmaneira ideal de representá-lo é através de <code class=\"language-text\">O(1)</code>.</p>\n<h3>Complexidade linear: O(n)</h3>\n<p>Quando a entrada do algoritmo é variável em tamanho, temos um comportamento\ndiferente:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">soma</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    total <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> array<span class=\"token punctuation\">:</span>\n        total <span class=\"token operator\">=</span> total <span class=\"token operator\">+</span> num</code></pre></div>\n<p>Geralmente quando temos algum loop, e ele está ligado ao <em>input</em>, dificilmente\nchegamos a um algoritmo de complexidade constante. No caso acima, podemos contar\nos passos da seguinte forma:</p>\n<ul>\n<li><code class=\"language-text\">n = tamanho(array)</code></li>\n<li><code class=\"language-text\">total = 0</code>: 1 operação</li>\n<li><code class=\"language-text\">atribuição de valor a num</code>: n operações</li>\n<li><code class=\"language-text\">total = total + num</code>: n * 2 operações</li>\n</ul>\n<p>Para cada elemento do <em>array</em>, executaremos uma soma <code class=\"language-text\">(total + num)</code> e uma\natribuição <code class=\"language-text\">(total = &lt;resultado&gt;)</code>. Chegamos à conclusão que\n<code class=\"language-text\">complexidade = 1 + (n * 2)</code>. Mas como chegamos a <code class=\"language-text\">O(n)</code>?</p>\n<p>Deixando a parte matemática de lado, quando trata-se de análise assintótica,\nestamos mais interessados no que realmente interfere na performance do\nalgoritmo. Ou seja, os valores constantes <code class=\"language-text\">(1 e 2)</code> nessa análise são detalhes\nse comparados ao impacto que <code class=\"language-text\">n</code> causa ao tempo de execução. Portanto, uma das\nmaneiras de encarar a mensuração do <em>Big O</em> é simplesmente ignorando as\nconstantes e focando no que é dinâmico, nos levando a <code class=\"language-text\">complexidade = n</code> e em\nconsequência ao <code class=\"language-text\">O(n)</code>.</p>\n<h2>Considerações finais</h2>\n<p>E como num passe de mágica, depois de certa intimidade com o <em>Big O Notation</em>,\nvocê passa a assumir a complexidade de um algoritmo com uma breve “olhadela”.\nAo ver um <em>loop</em> assume que é <code class=\"language-text\">n</code>, ao ver <em>loop</em> dentro de <em>loop</em>, que é <code class=\"language-text\">n²</code>,\ne assim por diante…</p>\n<p>Nos próximos <em>posts</em> vamos explorar algoritmos de diferentes complexidades,\nentrando em detalhes para entender os seus tempos de execução e alternativas\notimizadas.</p>\n<p>Até a próxima!</p>\n<p>Esse <em>post</em> foi originalmente escrito para o <a href=\"https://www.profissionaisti.com.br/2017/10/analise-de-algoritmos-como-medir/\" title=\"Leia mais no Profissionais TI\"><em>Profissionais TI</em></a>.</p>\n<h2>Referências</h2>\n<ul>\n<li><a href=\"https://pt.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation\">Khan Academy: Notação Big-O</a></li>\n<li><a href=\"https://stackoverflow.com/questions/3255/big-o-how-do-you-calculate-approximate-it\">Stackoverflow: Big O, how do you calculate/approximate it?</a></li>\n<li><a href=\"https://pt.stackoverflow.com/questions/33319/o-que-%C3%A9-a-complexidade-de-um-algoritmo\">Stackoverflow: O que é complexidade de um algoritmo?</a></li>\n<li><a href=\"https://www.udemy.com/complexity-theory-basics/\">Udemy: Complexity Theory Basics</a></li>\n</ul>","excerpt":"No post anterior,\nintroduzimos o conceito de Análise Assintótica e falamos brevemente sobre\no Big O Notation. Nesse post, vamos pincelar…","frontmatter":{"date":"2018-12-09T21:30:00.000Z","title":"Algoritmos: Como medir?","tags":["estrutura-de-dados","algoritmos"],"thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZklEQVQ4y+1UwW6CQBT0/z/AxJvxZKwexFgTYyPWagQToxA8CtaDULGijQVWcbqLWQOb0kt76MGXkH07sPPm7ZuQwx9H7k74e8LL5RInbBUfEed7HuI3N4VJIIqizAPfEYhYLlmRkzGM5XxNHmB7jvE8KSJWaNtrdDpPqNVqME0LlrVM3Uu//5JqVezksN9jYZpXQkJCSJKEw+EDzz0ZlcoDLeBAURQMBkOEYYB2u4PZdArDMDCZTNBqtXA8HjEej9HtdrHbeRgOB4hYy77/iUKhgOXyFdpMgzIawXHe8NhsolqtYm3bqNcllMtl9GQZ+XwexWKR3QFkSlYqlbBYmFCpgPP5fG3ZonI1TY8lv2+3MOZz+L4Pd7OhCgkt4GBLcdd1oaoqGo0GVqsVCCHwPI++t6Hreto2yWDtZMXpdEIQBKk7DMMQhOK3ofBJZfkvOeFkiFhsm2zP4UcPigZPGfv+t/lfhF9kfxgemtZu/wAAAABJRU5ErkJggg==","width":180,"height":180,"src":"/static/f4f2382271db5aa6759d84cb445249d8/d8216/algoritmos-2.png","srcSet":"/static/f4f2382271db5aa6759d84cb445249d8/d8216/algoritmos-2.png 1x"}},"publicURL":"/static/f4f2382271db5aa6759d84cb445249d8/algoritmos-2.png"}},"fields":{"readingTime":{"minutes":5.645},"slug":"/2018/12/09/algoritmos-como-medir.html"}},"site":{"siteMetadata":{"author":{"name":"Klaus Peter Laube","gravatar":"https://en.gravatar.com/userimage/12163112/d3ae0c6239980b01ff1f1730b65c2ebe.jpg"},"siteUrl":"https://klauslaube.com.br"}}},"pageContext":{"slug":"/2018/12/09/algoritmos-como-medir.html"}}}