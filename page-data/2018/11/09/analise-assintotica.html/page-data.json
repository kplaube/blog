{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018/11/09/analise-assintotica.html","result":{"data":{"markdownRemark":{"html":"<p>Devo confessar que durante a minha graduação, nunca prestei muita atenção na\nparte mais “teórica” da computação. O que eu queria era sentar e “codar”,\nsem realmente me preocupar com algoritmos, estruturas de dados, ou com os\nimpactos que a minha solução ocasionaria em um determinado ambiente.</p>\n<p>Com a idade vem a experiência, e com a experiência vem a necessidade de\nestressar diferentes pontos de vista antes de adotar solução X ou Y. Foi\na partir dessa necessidade que fui obrigado a revisitar alguns conceitos\nbásicos da Ciência da Computação, e fatalmente me senti motivado a compilar\nesse conhecimento em uma série de artigos.</p>\n<p>Se você, assim como eu, deu aquela dormida nas aulas de Teoria da Complexidade\nComputacional, junte-se a mim e vamos relembrar esses conceitos juntos.</p>\n<h2>Algoritmos e tempos de execução</h2>\n<p>Segundo o <em>Wikipedia</em>, um <a href=\"https://pt.wikipedia.org/wiki/Algoritmo\" title=\"Leia mais sobre no Wikipedia\">Algoritmo</a> é:</p>\n<blockquote>\n<p>(…) uma sequência finita de instruções bem definidas e não ambíguas,\ncada uma das quais devendo ser executadas mecânica ou eletronicamente\nem um intervalo de tempo finito e com uma quantidade de esforço finita.</p>\n</blockquote>\n<p>A sua aplicação pode ser composta por uma porção de algoritmos, cada um\ndestinado a um fim muito específico. Por exemplo, você pode ter um algoritmo\nresponsável por encontrar todos os pedidos vendidos no último mês, que contenham\num determinado produto. Com o advento do Big Data, inúmeros algoritmos são\npostos em prática para mineração e análise de dados, então, mesmo que exista\numa aplicação ou serviço resolvendo esses problemas para você, acredite...\nos algoritmos estarão lá.</p>\n<p>Um determinado algoritmo pode ter tempos de execução relativamente diferentes\nde acordo com o ambiente no qual ele esteja rodando. Se for num computador\n<em>Core i7</em> e <em>16GB</em> de <em>RAM</em>, é possível assumirmos que ele rodará consideravelmente\nmelhor do que se estivesse operando em um <em>Raspberry Pi</em>, por exemplo. Ainda há um\nsegundo cenário onde, talvez você tenha escrito o algoritmo perfeito em\n<a href=\"/tag/python.html\" title=\"Leia mais sobre Python\"><em>Python</em></a> ou <em>Ruby</em>, mas ele corre o risco de\nexecutar de forma mais lenta que um algoritmo em <em>Assembly</em> ou <em>C</em>.</p>\n<p>Partindo da premissa que um bom algoritmo é um conjunto de operações que resolvem\num problema em tempo e esforço atrativos, como podemos classificar se um algoritmo\né “rápido” ou não?</p>\n<p>É aí que entra a análise assintótica.</p>\n<h2>A Análise Assintótica</h2>\n<p>Segundo o <em>Wikibooks</em>, a <a href=\"https://en.wikibooks.org/wiki/Data_Structures/Asymptotic_Notation\" title=\"Leia mais sobre no Wikibooks\">análise assintótica</a> é:</p>\n<blockquote>\n<p>(…) a way of expressing the main component of the cost of an algorithm,\nusing idealized (not comparable) units of computational work.</p>\n</blockquote>\n<p>Em termos mais práticos, é uma forma de julgarmos se o nosso algoritmo é\neficiente, independente dos “recursos que o cercam” (como velocidade de\nprocessamento, quantidade de memória, latência de rede, etc).</p>\n<p><img src=\"/541be7c32edf6206dda051976fd420f3/matrix-view.gif\" alt=\"&#x22;Visão de código fonte do filme The Matrix&#x22;\" title=\"Análise assintótica é ver o algoritmo além do código, como o Neo em The Matrix (scifi.stackexchange.com)\"></p>\n<p>Removendo todas as variáveis que podem influenciar no tempo de execução,\nfocamos nossas atenções em como o algoritmo está escrito, em qual é a sua\nentrada, e se “ele por si” é a maneira mais eficiente para a resolução de\num determinado problema.</p>\n<p>Vale reforçar que a entrada é um fator de extrema importância no que tange\na análise assintótica. A análise é “input bound”, ou seja, a entrada\ninfluenciará diretamente no resultado do estudo. Por exemplo, quando\nordenamos um vetor de tamanho <code class=\"language-text\">n</code>, utilizando o algoritmo <em>Selection Sort</em>,\nteremos um tempo de execução de <code class=\"language-text\">n²</code> (já que o algoritmo pega um número,\ne compara com os demais números no vetor, repetindo essa operação até chegar\nao fim do dado estruturado).</p>\n<p>Ao fim da análise, podemos chegar a 2 conclusões diferentes: Melhor cenário\ne pior cenário.</p>\n<h2>Big O, Big Omega e Big Theta</h2>\n<p>Quem trabalha com desenvolvimento (ou até mesmo com computação num geral),\njá deve ter ouvido falar sobre o famigerado <em>Big O Notation</em>. Ele é uma notação\nassintótica muito famosa na análise de tempos de execução de algoritmos. O que\npode ser uma surpresa é que ele não é a única notação que temos disponível:</p>\n<ul>\n<li><strong>O(n)</strong>: Expressa o limite superior do tempo de execução de um algoritmo (pior cenário);</li>\n<li><strong>Ω(n)</strong>: Expressa o limite inferior do tempo de execução de um algoritmo (melhor cenário);</li>\n<li><strong>Θ(n)</strong>: Expressa limite superior e inferior do tempo de execução de um algoritmo (pior e melhor cenário).</li>\n</ul>\n<p>Além da expressão linear, temos outras notações que descrevem diferentes tempos\nde execução:</p>\n<ul>\n<li><strong>O(1)</strong>: Constante</li>\n<li><strong>O(log n)</strong>: Logarítmica</li>\n<li><strong>O(n)</strong>: Linear</li>\n<li><strong>O(n log n)</strong>: “Linearithmic” (maior que linear, menor que quadrática)</li>\n<li><strong>O(n²)</strong>: Quadrática</li>\n<li><strong>O(n³)</strong>: Cúbica</li>\n<li><strong>n<sup>O(1)</sup></strong>: Polinomial</li>\n<li><strong>2<sup>O(n)</sup></strong>: Exponencial</li>\n</ul>\n<p>De maneira simplista, <code class=\"language-text\">n</code> pode ser considerado como o número de operações que o\nalgoritmo leva para chegar ao seu final. <code class=\"language-text\">n</code> está intimamente ligado com a entrada\ndo seu algoritmo, onde quanto maior for o seu número, maior será o seu tempo de\nexecução.</p>\n<p>E como fazemos para contar o número de operações realizadas por um algoritmo?</p>\n<h2>Um pouquinho de prática</h2>\n<p>Voltando a citar o <em>Selection Sort</em>, que trata-se de um “greedy algorithm” para\nordenação de números em um vetor, temos a seguinte sequencia de operações:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for i from 1 to n-1 {\n   Encontre um elemento menor que a i-ésima posição, entre as n entradas.\n   Troque o elemento encontrado com a i-ésima entrada.\n}</code></pre></div>\n<p>Fazendo um pequeno <a href=\"http://pt.slideshare.net/henriquecarmona/aula-4-teste-de-mesa\" title=\"Veja mais no Slideshare\">teste de mesa</a>,\ncom o vetor (9, 2, 5, 7, 4, 8), temos o seguinte conjunto de procedimentos:</p>\n<ol>\n<li>\n<p><code class=\"language-text\">[9, 2, 5, 7, 4, 8]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=1</code>;</li>\n<li>Encontre o menor número entre posições 1 e 6;</li>\n<li>Troque <code class=\"language-text\">array[i]</code> com <code class=\"language-text\">array[2]</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">[2, 9, 5, 7, 4, 8]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=2</code>;</li>\n<li>Encontre o menor número entre posições 2 e 6;</li>\n<li>Troque <code class=\"language-text\">array[i]</code> com <code class=\"language-text\">array[5]</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">[2, 4, 5, 7, 9, 8]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=3</code>;</li>\n<li>Encontre o menor número entre posições 3 e 6;</li>\n<li>Troque <code class=\"language-text\">array[i]</code> com <code class=\"language-text\">array[3]</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">[2, 4, 5, 7, 9, 8]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=4</code>;</li>\n<li>Encontre o menor número entre posições 4 e 6;</li>\n<li>Troque <code class=\"language-text\">array[i]</code> com <code class=\"language-text\">array[4]</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">[2, 4, 5, 7, 9, 8]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=5</code>;</li>\n<li>Encontre o menor número entre posições 5 e 6;</li>\n<li>Troque <code class=\"language-text\">array[i]</code> com <code class=\"language-text\">array[5]</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">[2, 4, 5, 7, 8, 9]</code>:</p>\n<ul>\n<li><code class=\"language-text\">i=6</code>;</li>\n<li>Fim do laço.</li>\n</ul>\n</li>\n</ol>\n<p>Podemos separar a análise em 3 grupos:</p>\n<ul>\n<li>Tempo de execução para encontrar o menor elemento</li>\n<li>Tempo de execução para trocar de elemento</li>\n<li>Tempo de execução do laço</li>\n</ul>\n<p>Embora seja possível fazer uma análise detalhada, levando em consideração\no número de passos dentro de uma operação de swap de valores, e a aritmética\nenvolvendo as <code class=\"language-text\">n-i-1</code> chamadas que ocorrem dentro da função\n“Encontre o menor número entre posições”, para fins didáticos vamos adotar\numa abordagem superficial.</p>\n<p>Selecionar o menor elemento no <em>array</em> e fazer o <em>swap</em> para a primeira\nposição requer passar por todos os <code class=\"language-text\">n-1</code> elementos. Encontrar o próximo\nmenor elemento requer analisar os <code class=\"language-text\">n-1</code> elementos restantes. Com dois\nfor aninhados, executando em ordem <code class=\"language-text\">n</code>, já podemos esperar uma execução\nem <code class=\"language-text\">O(n²)</code>. É possível usar a <a href=\"https://en.wikipedia.org/wiki/Arithmetic_progression\" title=\"Leia mais sobre\">progressão aritmética</a>\npara comprovar essa hipótese:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(n − 1) + (n − 2) + ... + 2 + 1 = n(n - 1) / 2 ∈ Θ(n²)</code></pre></div>\n<p>Se revisarmos o algoritmo apresentado, é possível reparar que o\n<em>Selection Sort</em> tem no seu melhor e pior cenário o tempo de execução de\n<code class=\"language-text\">n²</code>, logo, podendo ser classificado como <code class=\"language-text\">Θ(n²)</code>.</p>\n<p>Nos próximos posts vamos nos aprofundar um pouco mais nos detalhes dessa\nanálise, e passar por alguns algoritmos úteis e muito comuns na nossa rotina.</p>\n<p>Até a próxima!</p>\n<p>Esse <em>post</em> foi originalmente escrito para o <a href=\"https://www.profissionaisti.com.br/2016/10/analise-de-algoritmos-analise-assintotica/\" title=\"Análise de algoritmos: Análise Assintótica\"><em>Profissionais TI</em></a>.</p>\n<h2>Referências</h2>\n<ul>\n<li><a href=\"https://pt.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/analysis-of-selection-sort\">Análise do Selection Sort – Khan Academy</a></li>\n<li><a href=\"https://justin.abrah.ms/computer-science/how-to-calculate-big-o.html\">Justin Abrahms – Big-O is easy to calculate, if you know how</a></li>\n<li><a href=\"http://discrete.gr/complexity/\">National Technical University of Athens – A gentle introduction to Algorithm Complexity Analysis</a></li>\n<li><a href=\"http://www.perlmonks.org/?node_id=573138\">Perl Monks – Big-O Notation: What’s is it good for?</a></li>\n<li><a href=\"http://www.tutorialspoint.com/data_structures_algorithms/asymptotic_analysis.htm\">Tutorials Point – Data Structures Asymptotic Analysis</a></li>\n<li><a href=\"https://en.wikibooks.org/wiki/Data_Structures/Asymptotic_Notation\">Wikibooks – Data Structures/Asymptotic Notation</a></li>\n<li><a href=\"https://pt.wikipedia.org/wiki/Algoritmo\">Wikipedia – Algoritmo</a></li>\n</ul>","excerpt":"Devo confessar que durante a minha graduação, nunca prestei muita atenção na\nparte mais “teórica” da computação. O que eu queria era sentar…","frontmatter":{"date":"2018-11-09T16:34:00.000Z","title":"Análise assintótica","tags":["estrutura-de-dados","algoritmos"],"thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAED/8QAGAEAAgMAAAAAAAAAAAAAAAAAAAECAwT/2gAMAwEAAhADEAAAAdxfhocQGAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAEFAh//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAdEAABAwUBAAAAAAAAAAAAAAAxAAERECFBYXGh/9oACAEBAAE/IZUjHc0tO171WYDaLQ4r/9oADAMBAAIAAwAAABDQEAH/xAAYEQEBAAMAAAAAAAAAAAAAAAABABARIf/aAAgBAwEBPxAAGeNtx//EABcRAQADAAAAAAAAAAAAAAAAABABEUH/2gAIAQIBAT8Q0qD/xAAfEAEAAgEFAAMAAAAAAAAAAAABESEAEDFBUWFxkdH/2gAIAQEAAT8QQbofLiCwzOX2PNLcu+0R+74xBCqLpT0eZFE4Uco9xILAyDtPeSwCqBB4daf/2Q==","width":180,"height":180,"src":"/static/9c3e93b9452135c8a0310d05364d4342/a8ad2/algoritmos.jpg","srcSet":"/static/9c3e93b9452135c8a0310d05364d4342/a8ad2/algoritmos.jpg 1x"}},"publicURL":"/static/9c3e93b9452135c8a0310d05364d4342/algoritmos.jpg"}},"fields":{"readingTime":{"minutes":6.745},"slug":"/2018/11/09/analise-assintotica.html"}},"site":{"siteMetadata":{"author":{"name":"Klaus Peter Laube","gravatar":"https://en.gravatar.com/userimage/12163112/d3ae0c6239980b01ff1f1730b65c2ebe.jpg"},"siteUrl":"https://klauslaube.com.br"}}},"pageContext":{"slug":"/2018/11/09/analise-assintotica.html"}},"staticQueryHashes":["2831923220","4114525740"]}