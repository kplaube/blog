<!DOCTYPE html><html lang=pt-br> <head><meta charset=utf-8><title>Os greedy algorithms | Klaus Laube</title><meta name=author content="Klaus Peter Laube"><meta name=description content='Quando estive revisando a disciplina de algoritmos, me deparei com os tais "algoritmos gulosos", ou greedy algorithms. Lembro que na época eu...'><meta name=robots content=index,follow><meta property=og:site_name content="Klaus Laube"><meta property=og:type content=website><meta name=keywords content="desenvolvimento, estrutura-de-dados, algoritmos"><meta property=og:title content="Os greedy algorithms"><meta property=og:description content='Quando estive revisando a disciplina de algoritmos, me deparei com os tais "algoritmos gulosos", ou greedy algorithms. Lembro que na época eu...'><meta property=og:url content=https://klauslaube.com.br/2019/01/27/os-greedy-algorithms.html><meta property=og:image content=https://klauslaube.com.br//images/blog/greedy-boo.jpg><meta property=fb:app_id content=262757647133878><meta name=google-site-verification content=xCq0H3B3JhkPcAdZ03J0vayijvH_g1rQVMZ_DVcMsQY><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=icon type=image/x-icon href=https://klauslaube.com.br/favicon.ico><link rel=alternate type=application/rss+xml title="Klaus Laube » Feed" href=https://klauslaube.com.br/feed/rss.xml><link rel=canonical href=https://klauslaube.com.br/2019/01/27/os-greedy-algorithms.html><link rel=stylesheet href=https://unpkg.com/purecss@1.0.0/build/pure-min.css integrity=sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w crossorigin=anonymous><link rel=stylesheet href=https://klauslaube.com.br/theme/css/styles.min.css?0830b1e2></head> <body> <div class="Page pure-g is-fullEntry"> <div class="PageHeader pure-u-1"> <nav class="pure-menu pure-menu-open pure-menu-horizontal"> <a href=https://klauslaube.com.br/index.html title="Home page" class="PageHeader-link pure-menu-heading pure-menu-link">Klaus<span class=u-highlighted>Laube</a> <ul class="PageHeader-menu pure-menu-list"> <li class=pure-menu-item> <a href=https://about.me/klauslaube class="PageHeader-menu-link pure-menu-link">Contato</a> </li> </ul> </nav> </div> <div class="PageContent pure-u-1"> <article class="Article u-box" itemscope itemtype=http://schema.org/BlogPosting> <div itemprop=image itemscope itemtype=http://schema.org/ImageObject> <meta itemprop=url content=https://klauslaube.com.br//images/blog/greedy-boo.jpg> </div> <span itemprop=mainEntityOfPage> <header> <h1 class=Article-title itemprop="headline name"> Os greedy algorithms </h1> <p class=Article-meta> Por <span class=Article-author itemprop=author>Klaus Peter Laube</span>. <span class=Article-pubDate> Publicado em <time datetime=2019-01-27T15:28:00-02:00 itemprop=datePublished>27 Jan, 2019</time> </span> </p> </header> <div class=Article-content itemprop=articleBody> <img src=/images/blog/algoritmos-3.png alt=Algoritmos class=representative-image width=180 height=180> <p>Quando estive revisando a disciplina de <a href=https://klauslaube.com.br/tag/algoritmos.html title="Leia mais sobre Algoritmos">algoritmos</a>, me deparei com os tais "algoritmos gulosos", ou <em>greedy algorithms</em>. Lembro que na época eu automaticamente associei o termo a soluções de baixa utilidade ou performance. Mal sabia eu que estive equivocado esse tempo todo.</p> <!-- PELICAN_END_SUMMARY --> <p>Os <em>greedy algorithms</em> são fundamentais nos estudos de algoritmos e otimizações, não à toa o mundo acadêmico faz questão de mencioná-los em uma variedade de cursos de algoritmos ou de computação. Mas algumas definições podem passar uma ideia equivocada sobre o que eles realmente são, e do que são capazes.</p> <h2>Definição</h2> <p>Embora a <em>Wikipedia</em> possua uma definição interessante sobre o assunto, foi no <em>GeeksforGeeks</em> que <a href=https://www.geeksforgeeks.org/greedy-algorithms/ title="Greedy Algorithms">encontrei uma passagem bem esclarecedora</a>:</p> <blockquote> <p>Greedy is an algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. So the problems where choosing locally optimal also leads to global solution are best fit for Greedy.</p> </blockquote> <p>O <em>Paulo Feofiloff</em> vai além em <a href=https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/guloso.html title="USP - Algoritmos gulosos">"Algoritmos gulosos"</a>:</p> <blockquote> <p>Para resolver um problema, um algoritmo guloso escolhe, em cada iteração, o objeto mais apetitoso que vê pela frente. (...) Um algoritmo guloso é míope: ele toma decisões com base nas informações disponíveis na iteração corrente, sem olhar as consequências que essas decisões terão no futuro. Um algoritmo guloso jamais se arrepende ou volta atrás: as escolhas que faz em cada iteração são definitivas.</p> </blockquote> <p>A estratégia gulosa tem por abordagem encontrar a melhor resposta para cada passo, sem se importar em resolver esse passo novamente ou com os passos seguintes, esperando como consequência um resultado global ótimo. Acabamos por ter algoritmos mais simples e intuitivos em grande parte dos casos, mas não necessariamente apresentando a melhor resposta.</p> <p><img class=align-center-keep-size src=/images/blog/greedy-boo.jpg width=750 height=422 title="Algoritmos gulosos são como o Maijin Boo. Gulosos em essência, mas nem por isso não eficazes (tvovermind.com)" alt="Algoritmos gulosos são como o Maijin Boo. Gulosos em essência, mas nem por isso não eficazes (tvovermind.com)"></p> <p>As propriedades desse paradigma podem lembrar outras formas de escrever algoritmos, portanto, é importante saber diferenciá-lo.</p> <h3>Greedy não é brute-force</h3> <p>É bom deixar claro que um algoritmo guloso não é um algoritmo de força bruta:</p> <ul> <li><em>Greedy</em> significa que o algoritmo, a cada passo, seleciona a melhor opção para aquele passo;</li> <li><em>Brute-force</em> significa que o algoritmo seleciona uma opção de uma maneira mais simples, óbvia ou direta. E que repete essa tentativa até encontrar o resultado esperado.</li> </ul> <h3>Greedy não é naive</h3> <p>Essa talvez tenha sido a origem da minha confusão. <em>Naive algorithms</em> são de certa forma o primeiro passo para quando você está tentando resolver um problema complexo: Primeiro faça funcionar, depois faça melhor.</p> <p>Em uma abordagem <em>naive</em>, não estamos necessariamente tentando resolver cada passo com a melhor opção possível, e sim tentando resolver o todo de maneira ingênua, sem nenhuma estrutura de dados rebuscada ou cálculo preparatório, e sem se preocupar com a performance do algoritmo em si.</p> <h3>Naive vs. Brute-force vs. Greedy</h3> <p>Uma maneira mais interessante de compreender como escrevemos um algoritmo com essas diferentes práticas é através do <a href=https://en.wikipedia.org/wiki/Knapsack_problem title="Leia o artigo na Wikipedia"><em>Knapsack Problem</em></a>. Nesse famoso problema temos um conjunto de itens, cada qual com seu determinado <code>peso</code> e <code>valor</code>, e temos por desafio colocar o maior valor possível dentro de uma mochila com um determinado limite de peso.</p> <ul> <li>Um exemplo do método <em>naive</em> seria pegarmos os itens mais leves e colocarmos na bolsa até não haver mais espaço;</li> <li>Com <em>brute-force</em>, testaríamos todas as combinações de itens até chegar ao valor máximo para o limite de peso da bolsa;</li> <li>Já com o paradigma <em>greedy</em>, por intuição, pegaríamos primeiro os itens mais valiosos, até atingirmos o peso total da bolsa.</li> </ul> <p>Todas as três formas chegam a um resultado. É possível afirmar que a primeira e última opção terão performance semelhantes, mas não necessariamente chegarão a um resultado ótimo. Encontrar o melhor resultado através da forma bruta, nesse problema, não é a melhor solução.</p> <h2>Qual o melhor uso de greedy algorithms?</h2> <p>Segundo o <em>Brilliant.org</em>, se as propriedades abaixo forem verdadeiras, pode-se aplicar a abordagem <em>greedy</em> para resolução do problema:</p> <ul> <li>Uma solução global ótima pode ser atingida ao escolher a opção ótima de cada passo;</li> <li>Um problema tem uma subestrutura ótima se uma solução ótima para o problema global conter as soluções ótimas para os sub-problemas.</li> </ul> <p>Em outras palavras:</p> <blockquote> <p>(...) greedy algorithms work on problems for which it is true that, at every step, there is a choice that is optimal for the problem up to that step, and after the last step, the algorithm produces the optimal solution of the complete problem.</p> </blockquote> <p>Algoritmos como <a href=https://brilliant.org/wiki/huffman-encoding/ title="Leia mais no Brilliant"><em>Huffman Code</em></a> e <a href=https://brilliant.org/wiki/dijkstras-short-path-finder/ title="Leia mais no Brilliant"><em>Dijkstra's Shortest Path</em></a> são <em>greedy algorithms</em> famosos que cumprem muito bem o seu papel. O <em>GeeksforGeeks</em> lista <a href=https://www.geeksforgeeks.org/greedy-algorithms/ title="Leia mais no GeeksforGeeks">uma porção de outros algoritmos e problemas que utilizam o paradigma com sucesso</a>. Um muito comum em entrevistas de emprego é o <a href=https://www.geeksforgeeks.org/minimum-swaps-bracket-balancing/ title="Leia no GeeksforGeeks"><em>Minimum Swaps for Bracket Balancing</em></a>.</p> <h2>Considerações finais</h2> <p>Compreendendo a diferença entre um <em>greedy</em> e um <em>naive algorithm</em>, fica mais fácil entender quando utilizar uma técnica ou outra. Uma abordagem ingênua funciona bem quando estamos começando a construir o algoritmo que solucionará um problema. De forma iterativa podemos melhorá-lo, até chegar aos valores de performance desejados.</p> <p>Uma abordagem <em>greedy</em> pode trazer resultados satisfatórios para a sua solução, mas nem sempre trará o melhor resultado. Caso as propriedades listadas acima se apliquem ao algoritmo que você procura, sem dúvida nenhuma é uma técnica que, além de lhe ajudar a escrever um solução mais intuitiva, te trará os resultados esperados.</p> <p>Se você ficou curioso sobre como resolver o <em>Knapsack Problem</em> de forma ótima, há a opção de utilizar <em>Dynamic Programming</em>, outro paradigma que tem certa semelhança com <em>greedy algorithms</em>, e que vamos falar sobre em outro <em>post</em>. Uma alternativa mais simples e intuitiva (e <em>greedy</em>) é criar uma terceira variável que armazene <code>peso / valor</code> e utilize esse valor no processo de ordenação (<a href=https://github.com/kplaube/rosetta-lua/blob/master/rosetta/lib/knapsack.lua title="Veja a resolução do problema em Lua">exemplo</a>).</p> <p>Até a próxima.</p> <h2>Referências</h2> <ul> <li><a href=https://brilliant.org/wiki/greedy-algorithm/ >Brilliant - Greedy algorithms</a></li> <li><a href=https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-c++/html/page441.html>Data Structures and Algorithms with Object-Oriented Design Patterns in C++ - Brute-Force and Greedy Algorithms</a></li> <li><a href=https://www.geeksforgeeks.org/greedy-algorithms/ >GeeksforGeeks - Greedy algorithms</a></li> <li><a href=https://smart--grid.net/cours-lessons-theory/algorithm/brute-force-naive-greedy-algorithm/ >Smart Grid - Brute Force/Naive/Greedy algorithm</a></li> <li><a href=https://stackoverflow.com/questions/47238823/why-selection-sort-is-not-greedy>Stackoverflow - Why selection sort is not greedy?</a></li> <li><a href=https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/guloso.html>USP - Algoritmos gulosos</a></li> <li><a href=https://en.wikipedia.org/wiki/Greedy_algorithm>Wikipedia - Greedy algorithm</a></li> </ul> </div> </span> <div class=Article-tags> <span class=Article-tagLabel>Tags:</span> <span itemprop=keywords> <a href=https://klauslaube.com.br/tag/desenvolvimento.html title="Leia mais sobre" class=Article-tagLink>desenvolvimento</a> <a href=https://klauslaube.com.br/tag/estrutura-de-dados.html title="Leia mais sobre" class=Article-tagLink>estrutura-de-dados</a> <a href=https://klauslaube.com.br/tag/algoritmos.html title="Leia mais sobre" class=Article-tagLink>algoritmos</a> </span> </div> <div class=Article-comments> <div id=disqus_thread></div> <script type=text/javascript>
        var disqus_shortname = "klauslaube";
        var disqus_identifier = "2019/01/27/os-greedy-algorithms.html";

        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </div> </article> </div> <footer class="PageFooter pure-u-1"> <div class=u-box> <p>O conteúdo deste blog está sob a licença <a class=PageFooter-link href=http://creativecommons.org/licenses/by/3.0/deed.pt_BR title="Distribua, adapte, use. Mas mencione o autor." rel=nofollow>Creative Commons Attribution 3.0</a>.</p> <p>O código está disponível em <a class=PageFooter-link href=https://github.com/kplaube/blog/ title=Contribute! rel=nofollow>GitHub</a>.</p> </div> </footer> </div> <script>
        (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[0];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-19657400-1');ga('send','pageview');
    </script> </body> </html>