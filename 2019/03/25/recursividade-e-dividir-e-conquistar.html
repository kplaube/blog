<!DOCTYPE html><html lang=pt-br> <head><meta charset=utf-8><title>Recursividade e o "dividir e conquistar" | Klaus Laube</title><meta name=author content="Klaus Peter Laube"><meta name=description content='Sabe aquelas pessoas que têm problemas em determinar qual lado é o "esquerdo" e qual lado é o "direito"? Admito, sem orgulho algum, que tenho o mesmo...'><meta name=robots content=index,follow><meta property=og:site_name content="Klaus Laube"><meta property=og:type content=website><meta name=keywords content="desenvolvimento, estrutura-de-dados-algoritmos, recursividade, divide-and-conquer"><meta property=og:title content="Recursividade e o " dividir e conquistar&quot;&quot;><meta property=og:description content='Sabe aquelas pessoas que têm problemas em determinar qual lado é o "esquerdo" e qual lado é o "direito"? Admito, sem orgulho algum, que tenho o mesmo...'><meta property=og:url content=https://klauslaube.com.br/2019/03/25/recursividade-e-dividir-e-conquistar.html><meta property=og:image content=https://klauslaube.com.br//images/blog/divide-and-conquer-napoleon.jpg><meta property=fb:app_id content=262757647133878><meta name=google-site-verification content=xCq0H3B3JhkPcAdZ03J0vayijvH_g1rQVMZ_DVcMsQY><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=icon type=image/x-icon href=https://klauslaube.com.br/favicon.ico><link rel=alternate type=application/rss+xml title="Klaus Laube » Feed" href=https://klauslaube.com.br/feed/rss.xml><link rel=canonical href=https://klauslaube.com.br/2019/03/25/recursividade-e-dividir-e-conquistar.html><link rel=stylesheet href=https://unpkg.com/purecss@1.0.0/build/pure-min.css integrity=sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w crossorigin=anonymous><link rel=stylesheet href=https://klauslaube.com.br/theme/css/styles.min.css?0830b1e2></head> <body> <div class="Page pure-g is-fullEntry"> <div class="PageHeader pure-u-1"> <nav class="pure-menu pure-menu-open pure-menu-horizontal"> <a href=https://klauslaube.com.br/index.html title="Home page" class="PageHeader-link pure-menu-heading pure-menu-link">Klaus<span class=u-highlighted>Laube</a> <ul class="PageHeader-menu pure-menu-list"> <li class=pure-menu-item> <a href=https://about.me/klauslaube class="PageHeader-menu-link pure-menu-link">Contato</a> </li> </ul> </nav> </div> <div class="PageContent pure-u-1"> <article class="Article u-box" itemscope itemtype=http://schema.org/BlogPosting> <div itemprop=image itemscope itemtype=http://schema.org/ImageObject> <meta itemprop=url content=https://klauslaube.com.br//images/blog/divide-and-conquer-napoleon.jpg> </div> <span itemprop=mainEntityOfPage> <header> <h1 class=Article-title itemprop="headline name"> Recursividade e o "dividir e conquistar" </h1> <p class=Article-meta> Por <span class=Article-author itemprop=author>Klaus Peter Laube</span>. <span class=Article-pubDate> Publicado em <time datetime=2019-03-25T18:55:00-03:00 itemprop=datePublished>25 Mar, 2019</time> </span> </p> </header> <div class=Article-content itemprop=articleBody> <img src=/images/blog/recursion.jpeg alt="Recursividade ilustrada" class=representative-image width=180 height=180> <p>Sabe aquelas pessoas que têm problemas em determinar qual lado é o "esquerdo" e qual lado é o "direito"? Admito, sem orgulho algum, que tenho o mesmo problema com recursividade. Meu cérebro simplesmente se embaralha, e preciso fazer um grande esforço para imaginar o que está acontecendo.</p> <!-- PELICAN_END_SUMMARY --> <p>A boa notícia é que assim como usar a mão do relógio (ou a mão que você escreve) ajuda a determinar o que é esquerda e direita, é possível utilizar alguns padrões de escrita de código para ajudar a entender o que está acontecendo em um algoritmo com recursividade.</p> <p>Mas como só a receita de bolo não basta... senta que lá vem história.</p> <h2>Napoleão style!</h2> <p>O "Dividir e Conquistar" (ou <em>Divide and Conquer</em>), assim como os <a href=https://klauslaube.com.br/2019/01/27/os-greedy-algorithms.html title="Os Greedy algorithms"><em>Greedy algorithms</em></a>, é um paradigma para construção de algoritmos (<em>algorithmic paradigm</em>), onde a ideia é resolver um determinado problema utilizando três passos diferentes:</p> <ul> <li>Dividir: Quebre um determinado problema em subproblemas do mesmo tipo;</li> <li>Conquistar: Resolva esses subproblemas de forma recursiva;</li> <li>Combinar: Combine as respostas apropriadamente.</li> </ul> <p>Algoritmos de ordenação famosos, como o <em>Quicksort</em> e o <em>Merge Sort</em>, utilizam esse paradigma para apresentar soluções com performance ótima.</p> <p><img class=align-center-keep-size src=/images/blog/divide-and-conquer-napoleon.jpg width=600 height=300 title="Não! Não esse Napoleon... (youtube.com)" alt="Não! Não esse Napoleon... (youtube.com)"></p> <p>Compreender essa estrutura é um bom passo para dominar funções recursivas. Na verdade, a utilização de recursividade parte do princípio que você seja capaz de quebrar um grande problema em problemas menores (e semelhantes). No fim, os dois conceitos se completam e é difícil imaginar um sem o outro. O <a href=https://www.tutorialspoint.com/data_structures_algorithms/divide_and_conquer.htm title="Data Structures - Divide and Conquer"><em>tutorialspoint</em></a> reforça essa idea:</p> <blockquote> <p>In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.</p> </blockquote> <p>Não será surpresa se vermos a mesma receita se repetir pelo resto desse <em>post</em>.</p> <h2>Uma função que chama a si mesmo</h2> <p>O <a href=https://pt.wikibooks.org/wiki/Algoritmos_e_Estruturas_de_Dados/Recursividade title="Algoritmos e Estruturas de Dados/Recursividade"><em>Wikibooks</em></a> explica de forma muito clara o que é recursividade:</p> <blockquote> <p>Recursão é um método de programação no qual uma função pode chamar a si mesma. O termo é usado de maneira mais geral para descrever o processo de repetição de um objeto de um jeito similar ao que já fora mostrado. Muitos problemas em computação tem a propriedade de que cada instância sua contém uma instância menor do mesmo problema.</p> </blockquote> <p>Em termos mais práticos, é como se criássemos uma função para fatorar, e essa função chamasse a ela mesma:</p> <div class=highlight><pre><span></span><span class=n>FUNÇÃO</span> <span class=n>fatorial</span><span class=p>(</span><span class=n>numero</span><span class=p>)</span>
    <span class=n>RETORNE</span> <span class=n>numero</span> <span class=o>*</span> <span class=n>fatorial</span><span class=p>(</span><span class=n>numero</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
<span class=n>FIM</span>
</pre></div> <p>Vamos fazer um rápido teste de mesa. Imagine que queremos saber o fatorial de 3:</p> <ul> <li><code>fatorial(3)</code>: Retorna <code>3 * fatorial(2)</code>;</li> <li><code>fatorial(2)</code>: Retorna <code>2 * fatorial(1)</code>;</li> <li>Por intuição (falaremos mais sobre esse passo a seguir), assumimos que <code>fatorial(1) == 1</code>.</li> </ul> <p>A função chama a si mesma recursivamente em uma versão menor da entrada (<code>n - 1</code>), e multiplica o resultado por <code>numero</code>. Podemos visualizar o resultado desse comportamento ao fazer o caminho "de baixo para cima" na lista acima: <code>1 * 2 * 3 = 6</code>.</p> <p><img class=align-center-keep-size src=/images/blog/recursion-russian-doll.png width=740 height=416 title="Duas referências no mesmo post. Ousado! (mashable.com)" alt="Duas referências no mesmo post. Ousado! (mashable.com)"></p> <p>Roubamos no exemplo anterior, quando dissemos que por intuição sabemos o resultado da última etapa. "Intuição" não funciona do ponto de vista do algoritmo, e acabaríamos com um <em>loop</em> infinito, uma vez que não informamos em qual momento a função tem que parar de chamar a si mesma. O caso acima, se executado em uma linguagem de programação, vai resultar no famoso <a href=http://ptcomputador.com/P/computer-programming-languages/88738.html title="O que é o estouro de pilha">estouro de pilha</a> (ou <a href=https://pt.stackoverflow.com/questions/59135/erro-stackoverflow title="Erro stack overflow no StackOverflow"><em>stack overflow</em></a>).</p> <p>Precisamos adicionar o que é conhecido por "caso base" (ou "condição de parada") ao algoritmo. É esse caso que vai determinar quando a função deve parar:</p> <div class=highlight><pre><span></span><span class=n>FUNÇÃO</span> <span class=n>fatorial</span><span class=p>(</span><span class=n>numero</span><span class=p>)</span>
    <span class=n>SE</span> <span class=n>numero</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=n>ENTÃO</span>
        <span class=n>RETORNE</span> <span class=mi>1</span>
    <span class=n>SENÃO</span>
        <span class=n>RETORNE</span> <span class=n>numero</span> <span class=o>*</span> <span class=n>fatorial</span><span class=p>(</span><span class=n>numero</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
<span class=n>FIM</span>
</pre></div> <p>Pronto! Podemos refazer o nosso teste de mesa:</p> <ul> <li><code>fatorial(3)</code>: Retorna <code>3 * fatorial(2)</code>;</li> <li><code>fatorial(2)</code>: Retorna <code>2 * fatorial(1)</code>;</li> <li><code>fatorial(1)</code>: Retorna <code>1</code>.</li> </ul> <p>É possível perceber uma estrutura que costuma se repetir em outros algoritmos que utilizam recursão:</p> <ul> <li>Um número limitado de casos base;</li> <li>Um caso recursivo;</li> <li>Uma chamada externa (ex.: <code>fatorial(3)</code>);</li> <li>Um conjunto de chamadas recursivas (ex.: <code>fatorial(3 - 1)</code>).</li> </ul> <h2>Tail recursion</h2> <p>Voltando ao exemplo <code>fatorial(3)</code>, uma melhor leitura da ordem de chamada seria a seguinte:</p> <ul> <li><code>fatorial(3)</code></li> <li><code>3 * fatorial(2)</code></li> <li><code>3 * (2 * fatorial(1))</code></li> <li><code>3 * (2 * (1))</code></li> </ul> <p>Cada linha cria um <a href=https://stackoverflow.com/questions/10057443/explain-the-concept-of-a-stack-frame-in-a-nutshell title="Explain the concept of a stack frame in a nutshell"><em>stack frame</em></a>, que é empilhado de acordo com a ordem das chamadas. Ao fim da última chamada recursiva, os <em>frames</em> são retirados gradativamente da pilha, como ilustrado no exemplo abaixo:</p> <p><img class=align-center-keep-size src=/images/blog/javascript-stack-example.png width=740 height=243 title="Exemplo de call stack em Javascript (thinkingincrowd.me)" alt="Exemplo de call stack em Javascript (thinkingincrowd.me)"></p> <p>Uma função recursiva é <em>tail recursive</em> quando a chamada recursiva é a última coisa executada pela função. No nosso exemplo, temos uma função que aparentemente possui essa característica. Porém, não é certo dizer que ela possui de fato recursão de cauda, uma vez que temos que considerar que <code>fatorial(numero - 1)</code> é usado dentro de <code>fatorial(numero)</code>. O exemplo abaixo passa a ideia de que a chamada da função não é a última coisa executada no <em>frame</em>:</p> <ul> <li>Chamada inicial: <code>fatorial(3)</code></li> <li>Frame 1: <code>3 * fatorial(2)</code></li> <li>Frame 2: <code>3 * (2 * fatorial(1))</code></li> <li>Frame 3: Atinge caso base em <code>fatorial(1)</code> e retorna <code>1</code></li> <li>Frame 2: <code>3 * (2 * (1))</code></li> <li>Frame 1: <code>3 * (2)</code></li> <li>Retorno da chamada inicial: <code>6</code></li> </ul> <p>Segundo o <a href=https://www.geeksforgeeks.org/tail-recursion/ title="Tail Recursion">GeeksForGeeks</a>:</p> <blockquote> <p>Consider the (...) function to calculate factorial of n. It is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we take a closer look, we can see that the value returned by fact(n-1) is used in fact(n), so the call to fact(n-1) is not the last thing done by fact(n)</p> </blockquote> <p>É preciso fazer uma manutenção no corpo da função:</p> <div class=highlight><pre><span></span><span class=n>FUNÇÃO</span> <span class=n>fatorial</span><span class=o>-</span><span class=n>interna</span><span class=p>(</span><span class=n>numero</span><span class=p>,</span> <span class=n>acumulador</span><span class=p>)</span>
    <span class=n>SE</span> <span class=n>numero</span> <span class=o>==</span> <span class=mi>0</span> <span class=n>ENTÃO</span>
        <span class=n>RETORNE</span> <span class=n>acumulador</span>
    <span class=n>SENÃO</span>
        <span class=n>RETORNE</span> <span class=n>fatorial</span><span class=o>-</span><span class=n>interna</span><span class=p>(</span><span class=n>numero</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>numero</span> <span class=o>*</span> <span class=n>acumulador</span><span class=p>)</span>

<span class=n>FUNÇÃO</span> <span class=n>fatorial</span><span class=p>(</span><span class=n>numero</span><span class=p>)</span>
    <span class=n>RETORNE</span> <span class=n>fatorial</span><span class=o>-</span><span class=n>interna</span><span class=p>(</span><span class=n>numero</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
<span class=n>FIM</span>
</pre></div> <p>Como resultado, teremos um <em>call stack</em> diferente:</p> <ul> <li>Chamada inicial: <code>fatorial(3)</code></li> <li>Frame 1: <code>fatorial-interna(3, 1)</code></li> <li>Frame 2: <code>fatorial-interna(2, 3)</code></li> <li>Frame 3: <code>fatorial-interna(1, 6)</code></li> <li>Frame 4: Atinge caso base em <code>fatorial-interna(0, 6)</code> e retorna <code>6</code></li> <li>Frame 3: Retorno de <code>6</code></li> <li>Frame 2: Retorno de <code>6</code></li> <li>Frame 1: Retorno de <code>6</code></li> <li>Retorno da chamada inicial: <code>6</code></li> </ul> <p>Qual a real motivação em utilizar funções com recursão de cauda? Esse tipo de função pode ser otimizada pelo interpretador/compilador, portanto, o seu uso é encorajado em <a href=https://www.quora.com/Which-programming-languages-support-tail-recursion-optimization-out-of-the-box title="Which programming languages support tail recursion optimization out of the box?">linguagens que suportam essa funcionalidade</a>. De forma bem resumida, uma vez que a chamada recursiva é o último "statement", não há nada mais para ser executado pela função corrente, podendo utilizar o mesmo <em>stack frame</em>, <a href=https://www.geeksforgeeks.org/tail-call-elimination/ title="Tail Call Elimination">minimizando o esforço de empilhar e desempilhar chamadas</a>:</p> <ul> <li>Chamada inicial: <code>fatorial(3)</code></li> <li>Frame 1: <code>fatorial-interna(3, 1)</code></li> <li>Frame 1: <code>fatorial-interna(2, 3)</code></li> <li>Frame 1: <code>fatorial-interna(1, 6)</code></li> <li>Frame 1: Atinge caso base em <code>fatorial-interna(0, 6)</code> e retorna <code>6</code></li> <li>Retorno da chamada inicial: <code>6</code></li> </ul> <h2>Na prática</h2> <p>Vamos para uma abordagem mais prática, e para esse bloco, nada melhor que um dos desafios mais populares em entrevistas de emprego: Determinar se uma palavra é palíndromo.</p> <p>Segundo o <a href=https://www.todamateria.com.br/palindromo/ title=Palíndromo>TodaMatéria</a>:</p> <blockquote> <p>Palíndromo, do grego palin (novo) e dromo (percurso), é toda palavra ou frase que pode ser lida de trás pra frente e que, independente da direção, mantém o seu sentido.</p> </blockquote> <p>Vamos nos ater apenas à palavra. Utilizando a ideia de dividir e conquistar, é possível imaginar o seguinte algoritmo:</p> <p><strong>Dividir:</strong> Recebo determinada palavra, ou qualquer fração da mesma (exemplo: <code>arara</code>, <code>rar</code>, <code>a</code>).</p> <p><strong>Conquistar:</strong></p> <ul> <li>Se a largura da palavra for igual a <code>1</code> (exemplo: <code>a</code>), é palíndromo. Esse é um caso base;</li> <li>Senão, se primeira e última letra da palavra forem diferentes (exemplo: <code>araro</code>), não é palíndromo. Esse é o segundo caso base;</li> <li>Senão, retiramos a primeira e última letra da palavra, e passamos a nova palavra como parâmetro recursivamente (exemplo: <code>rar</code>).</li> </ul> <p><strong>Combinar:</strong> O resultado do último caso base executado vai dizer se o parâmetro passado é palíndromo ou não.</p> <p>Em <a href=https://klauslaube.com.br/tag/javascript.html title="Leia mais sobre Javascript"><em>Javascript</em></a>, podemos reproduzir as condições acima da seguinte forma:</p> <div class=highlight><pre><span></span><span class=kr>const</span> <span class=nx>isPalindrome</span> <span class=o>=</span> <span class=nx>word</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=c1>// Caso base #1</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>word</span><span class=p>.</span><span class=nx>length</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Caso base #2</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>word</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!==</span> <span class=nx>word</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Chamada recursiva</span>
  <span class=k>return</span> <span class=nx>isPalindrome</span><span class=p>(</span><span class=nx>str</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>));</span>
<span class=p>};</span>
</pre></div> <p>Acredito que deixando a chamada recursiva para o final, além de ser mais fácil de imaginar o problema e seus diferentes casos, "ganhamos" a característica de <em>tail recursion</em>.</p> <h2>Considerações finais</h2> <p>Recursividade sempre é um assunto que demanda um pouco mais de energia na leitura de um código, principalmente se você (assim como eu) prefere a forma iterativa (com <code>for</code> ou <code>while</code> e utilizando uma <code>stack</code> como estrutura de dados), mas sem dúvida alguma que compreender o <em>divide and conquer</em> e praticar uma forma mais estruturada de pensar facilita na compreensão de problemas com recursão.</p> <p>Até a próxima.</p> <h2>Referências</h2> <ul> <li><a href=https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/ >GeeksForGeeks - Divide and Conquer Algorithm. Introduction</a></li> <li><a href=https://www.geeksforgeeks.org/tail-recursion/ >GeeksForGeeks - Tail recursion</a></li> <li><a href=https://pt.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion>Khan Academy - Recursividade</a></li> <li><a href=https://cs.stackexchange.com/questions/6230/what-is-tail-recursion>StackExchange - What is tail recursion?</a></li> <li><a href=https://www.tutorialspoint.com/data_structures_algorithms/divide_and_conquer.htm>TutorialsPoint - Divide and Conquer</a></li> <li><a href=https://pt.wikibooks.org/wiki/Algoritmos_e_Estruturas_de_Dados/Recursividade>Wikibooks - Algoritmos e Estruturas de Dados/Recursividade</a></li> <li><a href=https://pt.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)>Wikipedia - Recursividade (ciência da computação)</a></li> </ul> </div> </span> <div class=Article-tags> <span class=Article-tagLabel>Tags:</span> <span itemprop=keywords> <a href=https://klauslaube.com.br/tag/desenvolvimento.html title="Leia mais sobre" class=Article-tagLink>desenvolvimento</a> <a href=https://klauslaube.com.br/tag/estrutura-de-dados-algoritmos.html title="Leia mais sobre" class=Article-tagLink>estrutura-de-dados. algoritmos</a> <a href=https://klauslaube.com.br/tag/recursividade.html title="Leia mais sobre" class=Article-tagLink>recursividade</a> <a href=https://klauslaube.com.br/tag/divide-and-conquer.html title="Leia mais sobre" class=Article-tagLink>divide-and-conquer</a> </span> </div> <div class=Article-comments> <div id=disqus_thread></div> <script type=text/javascript>
        var disqus_shortname = "klauslaube";
        var disqus_identifier = "2019/03/25/recursividade-e-dividir-e-conquistar.html";

        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </div> </article> </div> <footer class="PageFooter pure-u-1"> <div class=u-box> <p>O conteúdo deste blog está sob a licença <a class=PageFooter-link href=http://creativecommons.org/licenses/by/3.0/deed.pt_BR title="Distribua, adapte, use. Mas mencione o autor." rel=nofollow>Creative Commons Attribution 3.0</a>.</p> <p>O código está disponível em <a class=PageFooter-link href=https://github.com/kplaube/blog/ title=Contribute! rel=nofollow>GitHub</a>.</p> </div> </footer> </div> <script>
        (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[0];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-19657400-1');ga('send','pageview');
    </script> </body> </html>