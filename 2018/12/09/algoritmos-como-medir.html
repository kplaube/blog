<!DOCTYPE html><html lang=pt-br> <head><meta charset=utf-8><title>Algoritmos: Como medir? | Klaus Laube</title><meta name=author content="Klaus Peter Laube"><meta name=description content="No post anterior, introduzimos o conceito de Análise Assintótica e falamos brevemente sobre o Big O Notation. Nesse post, vamos pincelar sobre como..."><meta name=robots content=index,follow><meta property=og:site_name content="Klaus Laube"><meta property=og:type content=website><meta name=keywords content="desenvolvimento, estrutura-de-dados, algoritmos"><meta property=og:title content="Algoritmos: Como medir?"><meta property=og:description content="No post anterior, introduzimos o conceito de Análise Assintótica e falamos brevemente sobre o Big O Notation. Nesse post, vamos pincelar sobre como..."><meta property=og:url content=https://klauslaube.com.br/2018/12/09/algoritmos-como-medir.html><meta property=og:image content=https://klauslaube.com.br//images/blog/wikipedia-merge-sort.png><meta property=fb:app_id content=262757647133878><meta name=google-site-verification content=xCq0H3B3JhkPcAdZ03J0vayijvH_g1rQVMZ_DVcMsQY><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=icon type=image/x-icon href=https://klauslaube.com.br/favicon.ico><link rel=alternate type=application/rss+xml title="Klaus Laube » Feed" href=https://klauslaube.com.br/feed/rss.xml><link rel=canonical href=https://klauslaube.com.br/2018/12/09/algoritmos-como-medir.html><link rel=stylesheet href=https://unpkg.com/purecss@1.0.0/build/pure-min.css integrity=sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w crossorigin=anonymous><link rel=stylesheet href=https://klauslaube.com.br/theme/css/styles.min.css?0830b1e2></head> <body> <div class="Page pure-g is-fullEntry"> <div class="PageHeader pure-u-1"> <nav class="pure-menu pure-menu-open pure-menu-horizontal"> <a href=https://klauslaube.com.br/index.html title="Home page" class="PageHeader-link pure-menu-heading pure-menu-link">Klaus<span class=u-highlighted>Laube</a> <ul class="PageHeader-menu pure-menu-list"> <li class=pure-menu-item> <a href=https://about.me/klauslaube class="PageHeader-menu-link pure-menu-link">Contato</a> </li> </ul> </nav> </div> <div class="PageContent pure-u-1"> <article class="Article u-box" itemscope itemtype=http://schema.org/BlogPosting> <div itemprop=image itemscope itemtype=http://schema.org/ImageObject> <meta itemprop=url content=https://klauslaube.com.br//images/blog/wikipedia-merge-sort.png> </div> <span itemprop=mainEntityOfPage> <header> <h1 class=Article-title itemprop="headline name"> Algoritmos: Como medir? </h1> <p class=Article-meta> Por <span class=Article-author itemprop=author>Klaus Peter Laube</span>. <span class=Article-pubDate> Publicado em <time datetime=2018-12-09T21:30:00-02:00 itemprop=datePublished>09 Dez, 2018</time> </span> </p> </header> <div class=Article-content itemprop=articleBody> <img src=/images/blog/algoritmos-2.jpg alt=Algoritmos class=representative-image width=180 height=180> <p>No <a href=https://klauslaube.com.br/2018/11/09/analise-assintotica.html title="Leia mais sobre Análise Assintótica"><em>post</em> anterior</a>, introduzimos o conceito de Análise Assintótica e falamos brevemente sobre o <em>Big O Notation</em>. Nesse <em>post</em>, vamos pincelar sobre como mensurar um algoritmo utilizando a notação.</p> <!-- PELICAN_END_SUMMARY --> <p>Mas antes de mais nada é preciso reforçar: O <em>Big O</em> é apenas uma das métricas (número de passos proporcional ao tamanho do seu <em>input</em>) que pode te levar à conclusão de que o seu algoritmo é eficiente ou não. Em momento de implementação, outras métricas como memória, tempo, acesso a recursos e consumo de energia podem impactar nesse resultado.</p> <p>Para tanto, é comum termos duas formas distintas de análise:</p> <ul> <li><strong>Empírica:</strong> Tempo de execução do código, implementado na linguagem de programação de sua escolha.</li> <li><strong>Analítica:</strong> Não leva em consideração o ambiente no qual o seu algoritmo irá executar, representando através de uma ordem de grandeza o tempo de execução do algoritmo.</li> </ul> <p>Vamos focar no método analítico, claro. Se você está interessado no método empírico, ferramentas de <em>profiling</em> podem te dar ótimas dicas sobre a performance da sua solução.</p> <h2>Tempo x Espaço</h2> <p>É possível utilizar o <em>Big O</em> para medirmos quanto de espaço que um determinado algoritmo ocupa. Na <em>Wikipedia</em> existe inúmeros <em>wikis</em> sobre algoritmos famosos, e grande parte deles apresenta a seguinte estrutura:</p> <p><img class=align-center-keep-size src=/images/blog/wikipedia-merge-sort.png width=331 height=514 title="Exemplo de card do Wikipedia mostrando os tempos de um algoritmo (wikipedia)" alt="Exemplo de card do Wikipedia mostrando os tempos de um algoritmo (wikipedia)"></p> <p>O <em>Merge sort</em>, um dos mais famosos algoritmos de ordenação, além de ter uma performance média de <code>O (n log n)</code>, em seu pior cenário ocupa <code>O(n)</code> de espaço. Onde <code>n</code> corresponde ao tamanho da entrada do algoritmo. Logo, se você passar um <em>array</em> de 10 posições para o <em>Merge sort</em> ordenar, ele ocupará outras 10 posições ao fim do processo.</p> <p>Em contrapartida, o <em>Bubble sort</em>, também famoso mas nada performático (<code>O(n²)</code>), ocupa <code>O(1)</code> (não necessitando de novas posições na memória para fazer a ordenação).</p> <p>Se você estiver projetando a sua solução para um ambiente limitado, será necessário levar em consideração o espaço, mas é muito comum nos tempos atuais <a href=https://klauslaube.com.br/2012/05/14/o-cache-e-o-http.html title="O Cache e o HTTP">sacrificarmos memória em prol do tempo de execução</a>.</p> <h2>Quanto mais próximo de linear, melhor</h2> <p>Voltando o foco ao tempo de execução, é possível categorizarmos um bom algoritmo quando ele é o mais próximo possível de linear (se ele for sublinear ou constante, melhor ainda). Ou seja:</p> <ul> <li>Se ordernar <strong>10 items</strong> leva <strong>1 milissegundo</strong>;</li> <li>Ordenar <strong>20 items</strong> deveria levar <strong>2 milissegundos</strong>;</li> <li>E ordenar <strong>100 items</strong> deveria levar <strong>10 milissegundos</strong>.</li> </ul> <p>Esse comportamento é linear, resultando em <code>O(n)</code>. Mas o comportamento abaixo não é o dos melhores:</p> <ul> <li>Se ordenar <strong>10 items</strong> leva <strong>1 milissegundo</strong>;</li> <li>E ordenar <strong>20 items</strong> leva <strong>4 milissegundos</strong>;</li> <li>E ordenar <strong>100 items</strong> leva <strong>100 milissegundos</strong>;</li> <li>Temos uma progressão quadrática, resultando em <code>O(n²)</code>.</li> </ul> <p>Algo não tão desejável em se tratando de algoritmos.</p> <h2>Mais um pouquinho de teoria</h2> <p>Vamos gastar um pouco de teoria aqui para definir <em>Big O</em>:</p> <blockquote> <p>Se um tempo de execução é O(f(n)), então para um n suficientemente grande, o tempo de execução é no máximo k*f(n) para alguma constante k.</p> </blockquote> <p><img class=align-center-keep-size src=/images/blog/big-o.png width=359 height=215 title="f(n) e Big O (khanacademy.org)" alt="f(n) e Big O (khanacademy.org)"></p> <p>Dizemos que o tempo de execução é <code>big-O de f(n)</code> ou só <code>O de f(n)</code>. Com isso informamos limites assintóticos superiores, ou seja, que no pior cenário o tempo de execução cresce de uma maneira até atingir determinado limite, mas poderia crescer mais devagar. Não podemos desconsiderar que o <em>input</em> tem que ser suficientemente grande (repare na linha pontilhada). Não é incomum vermos algoritmos que performem em <code>O(n log n)</code> tendo um desempenho ruim com um conjunto de dados pequeno.</p> <h2>Agora sim! Vamos contar</h2> <h3>Complexidade constante: O(1)</h3> <p>Queremos calcular qual é a complexidade de um algoritmo de troca de valores:</p> <div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>swap</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>):</span>
    <span class=n>temp_num</span> <span class=o>=</span> <span class=n>num1</span>
    <span class=n>num1</span> <span class=o>=</span> <span class=n>num2</span>
    <span class=n>num2</span> <span class=o>=</span> <span class=n>temp_num</span>
</pre></div> <p>Podemos, em teoria, contar cada atribuição de valor executada pelo algoritmo como um “passo”. Teríamos <code>complexidade = 3</code>, e esse resultado nunca mudará, não importa qual valor que passe de entrada. Logo, é possível dizer que a complexidade desse algoritmo é constante, representada por <code>O(1)</code>.</p> <p><img class=align-center-keep-size src=/images/blog/social-network-algorithm.jpg width=640 height=360 title="Em um piscar de olhos, você estará rabiscando algoritmos nas janelas da sua casa (blogossus.com)" alt="Em um piscar de olhos, você estará rabiscando algoritmos nas janelas da sua casa (blogossus.com)"></p> <p>Pode parecer confuso não utilizar <code>O(3)</code>, mas seguindo a definição matemática apresentada anteriormente, quando eu assumo que meu algoritmo tem complexidade <code>O(1)</code>, estou dizendo que o seu limite assintótico superior é menor ou igual a <code>k * f(n)</code>. Se considerarmos o <code>k</code> como constante representando a quantidade de atribuições do nosso algoritmo <code>(3)</code> e <code>f(n)</code> como o <em>running time</em> <code>(1)</code>, temos como <em>upper bound</em> o valor <code>3</code>.</p> <p>Em outras palavras: Se o tempo de execução do seu algoritmo é constante, a maneira ideal de representá-lo é através de <code>O(1)</code>.</p> <h3>Complexidade linear: O(n)</h3> <p>Quando a entrada do algoritmo é variável em tamanho, temos um comportamento diferente:</p> <div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>soma</span><span class=p>(</span><span class=n>array</span><span class=p>):</span>
  <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span>
  <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>array</span><span class=p>:</span>
      <span class=n>total</span> <span class=o>=</span> <span class=n>total</span> <span class=o>+</span> <span class=n>num</span>
</pre></div> <p>Geralmente quando temos algum loop, e ele está ligado ao <em>input</em>, dificilmente chegamos a um algoritmo de complexidade constante. No caso acima, podemos contar os passos da seguinte forma:</p> <ul> <li><code>n = tamanho(array)</code></li> <li><code>total = 0</code>: 1 operação</li> <li><code>atribuição de valor a num</code>: n operações</li> <li><code>total = total + num</code>: n * 2 operações</li> </ul> <p>Para cada elemento do <em>array</em>, executaremos uma soma <code>(total + num)</code> e uma atribuição <code>(total = &lt;resultado&gt;)</code>. Chegamos à conclusão que <code>complexidade = 1 + (n * 2)</code>. Mas como chegamos a <code>O(n)</code>?</p> <p>Deixando a parte matemática de lado, quando trata-se de análise assintótica, estamos mais interessados no que realmente interfere na performance do algoritmo. Ou seja, os valores constantes <code>(1 e 2)</code> nessa análise são detalhes se comparados ao impacto que <code>n</code> causa ao tempo de execução. Portanto, uma das maneiras de encarar a mensuração do <em>Big O</em> é simplesmente ignorando as constantes e focando no que é dinâmico, nos levando a <code>complexidade = n</code> e em consequência ao <code>O(n)</code>.</p> <h2>Considerações finais</h2> <p>E como num passe de mágica, depois de certa intimidade com o <em>Big O Notation</em>, você passa a assumir a complexidade de um algoritmo com uma breve “olhadela”. Ao ver um <em>loop</em> assume que é <code>n</code>, ao ver <em>loop</em> dentro de <em>loop</em>, que é <code>n²</code>, e assim por diante…</p> <p>Nos próximos <em>posts</em> vamos explorar algoritmos de diferentes complexidades, entrando em detalhes para entender os seus tempos de execução e alternativas otimizadas.</p> <p>Até a próxima!</p> <p>Esse <em>post</em> foi originalmente escrito para o <a href=https://www.profissionaisti.com.br/2017/10/analise-de-algoritmos-como-medir/ title="Leia mais no Profissionais TI"><em>Profissionais TI</em></a>.</p> <h2>Referências</h2> <ul> <li><a href=https://pt.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation>Khan Academy: Notação Big-O</a></li> <li><a href=https://stackoverflow.com/questions/3255/big-o-how-do-you-calculate-approximate-it>Stackoverflow: Big O, how do you calculate/approximate it?</a></li> <li><a href=https://pt.stackoverflow.com/questions/33319/o-que-%C3%A9-a-complexidade-de-um-algoritmo>Stackoverflow: O que é complexidade de um algoritmo?</a></li> <li><a href=https://www.udemy.com/complexity-theory-basics/ >Udemy: Complexity Theory Basics</a></li> </ul> </div> </span> <div class=Article-tags> <span class=Article-tagLabel>Tags:</span> <span itemprop=keywords> <a href=https://klauslaube.com.br/tag/desenvolvimento.html title="Leia mais sobre" class=Article-tagLink>desenvolvimento</a> <a href=https://klauslaube.com.br/tag/estrutura-de-dados.html title="Leia mais sobre" class=Article-tagLink>estrutura-de-dados</a> <a href=https://klauslaube.com.br/tag/algoritmos.html title="Leia mais sobre" class=Article-tagLink>algoritmos</a> </span> </div> <div class=Article-comments> <div id=disqus_thread></div> <script type=text/javascript>
        var disqus_shortname = "klauslaube";
        var disqus_identifier = "2018/12/09/algoritmos-como-medir.html";

        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </div> </article> </div> <footer class="PageFooter pure-u-1"> <div class=u-box> <p>O conteúdo deste blog está sob a licença <a class=PageFooter-link href=http://creativecommons.org/licenses/by/3.0/deed.pt_BR title="Distribua, adapte, use. Mas mencione o autor." rel=nofollow>Creative Commons Attribution 3.0</a>.</p> <p>O código está disponível em <a class=PageFooter-link href=https://github.com/kplaube/blog/ title=Contribute! rel=nofollow>GitHub</a>.</p> </div> </footer> </div> <script>
        (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[0];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-19657400-1');ga('send','pageview');
    </script> </body> </html>