<!DOCTYPE html><html lang=pt-br> <head><meta charset=utf-8><title>Django e Cache: Uma dupla de alta performance - Parte 2 | Klaus Laube</title><meta name=author content="Klaus Peter Laube"><meta name=description content="Podemos utilizar a camada de cache em diferentes pontos da aplicação. Com o esquema de middlewares do Django, podemos ter essa camada aplicada diretamente ao fluxo de interpretação do framework, o que pode reduzir consideravelmente o uso de recursos de nossa hospedagem, sem mesmo termos alterado código das nossas apps."><meta name=robots content=index,follow><meta property=og:site_name content="Klaus Laube"><meta property=og:type content=website><meta name=keywords content="desenvolvimento, web, python, django, memcached, johnny-cache, cache"><meta property=og:title content="Django e Cache: Uma dupla de alta performance - Parte 2"><meta property=og:description content="Podemos utilizar a camada de cache em diferentes pontos da aplicação. Com o esquema de middlewares do Django, podemos ter essa camada aplicada diretamente ao fluxo de interpretação do framework, o que pode reduzir consideravelmente o uso de recursos de nossa hospedagem, sem mesmo termos alterado código das nossas apps."><meta property=og:url content=https://klauslaube.com.br/2012/07/22/django-e-cache-uma-dupla-de-alta-performance-2.html><meta property=og:image content><meta property=fb:app_id content=262757647133878><meta name=google-site-verification content=xCq0H3B3JhkPcAdZ03J0vayijvH_g1rQVMZ_DVcMsQY><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=icon type=image/x-icon href=https://klauslaube.com.br/favicon.ico><link rel=alternate type=application/rss+xml title="Klaus Laube » Feed" href=https://klauslaube.com.br/feed/rss.xml><link rel=canonical href=https://klauslaube.com.br/2012/07/22/django-e-cache-uma-dupla-de-alta-performance-2.html><link rel=stylesheet href=https://unpkg.com/purecss@1.0.0/build/pure-min.css integrity=sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w crossorigin=anonymous><link rel=stylesheet href=https://klauslaube.com.br/theme/css/styles.min.css?0830b1e2></head> <body> <div class="Page pure-g is-fullEntry"> <div class="PageHeader pure-u-1"> <nav class="pure-menu pure-menu-open pure-menu-horizontal"> <a href=https://klauslaube.com.br/index.html title="Home page" class="PageHeader-link pure-menu-heading pure-menu-link">Klaus<span class=u-highlighted>Laube</a> <ul class="PageHeader-menu pure-menu-list"> <li class=pure-menu-item> <a href=https://about.me/klauslaube class="PageHeader-menu-link pure-menu-link">Contato</a> </li> </ul> </nav> </div> <div class="PageContent pure-u-1"> <article class="Article u-box" itemscope itemtype=http://schema.org/BlogPosting> <div itemprop=image itemscope itemtype=http://schema.org/ImageObject> <meta itemprop=url content> </div> <span itemprop=mainEntityOfPage> <header> <h1 class=Article-title itemprop="headline name"> Django e Cache: Uma dupla de alta performance - Parte 2 </h1> <p class=Article-meta> Por <span class=Article-author itemprop=author>Klaus Peter Laube</span>. <span class=Article-pubDate> Publicado em <time datetime=2012-07-22T14:33:58-03:00 itemprop=datePublished>22 Jul, 2012</time> </span> </p> </header> <div class=Article-content itemprop=articleBody> <img src=/images/blog/memcached-logo.jpg alt="Logo do Memcached" class=representative-image width=180 height=180> <p>Continuando o <em>post</em> <a href=https://klauslaube.com.br/2012/06/17/django-e-cache-uma-dupla-de-alta-performance-1.html title="Leia a parte 1 deste artigo"><em>Django</em> e <em>Cache</em>: Uma dupla de alta performance</a>, vamos ver na prática como utilizar o <em>framework</em> de <a href=https://klauslaube.com.br/tag/cache.html title="Leia mais sobre Cache"><em>cache</em></a> do <a href=https://klauslaube.com.br/tag/django.html title="Leia mais sobre Django"><em>Django</em></a>.</p> <p>Embora eu esteja utilizando o <a href=https://klauslaube.com.br/tag/memcached.html title="Leia mais sobre Memcached"><em>Memcached</em></a> para escrever estes artigos, vale ressaltar que a abstração do <em>Django</em> lhe permite utilizar a <a href=https://docs.djangoproject.com/en/dev/topics/cache/#using-a-custom-cache-backend title="Django Documentation - Custom backends">ferramenta mais apropriada para você</a>.</p> <!-- PELICAN_END_SUMMARY --> <h2>Diferentes maneiras de “cachear” a aplicação</h2> <p>Podemos utilizar a camada de <em>cache</em> em diferentes pontos da aplicação. Por exemplo, podemos utilizá-la antes de uma consulta ao banco de dados, armazenar resultados de operações complexas, armazenar o <em>parsing</em> de um <em>template</em>, etc. Com o esquema de <em>middlewares</em> do <em>Django</em>, podemos ter essa camada aplicada diretamente ao fluxo de interpretação do <em>framework</em>, o que pode reduzir consideravelmente o uso de recursos de nossa hospedagem, sem mesmo termos alterado código das nossas <em>apps</em>.</p> <p>Vamos ver a diferença, e casos de usos, dessas formas de utilização do <em>cache</em>.</p> <h3>Granular</h3> <p>Quando você quer ser “incisivo”, utilizar a <em>API</em> de forma “granular” é uma ótima opção.</p> <p>Por exemplo, no <a href=http://globoesporte.globo.com title="A melhor cobertura sobre o Futebol e Outros Esportes, no Brasil e no Mundo"><em>Globoesporte.com</em></a> nós fazemos algumas consultas a um <a href=http://virtuoso.openlinksw.com/ title="Conheça o Virtuoso">banco de dados semântico</a> para trazer informações de eventos, jogos e atletas. Como esta consulta é consideravelmente demorada, utilizamos a <em>API</em> de <em>cache</em> para melhorar os tempos de resposta. Exemplo:</p> <div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>django.core.cache</span> <span class=kn>import</span> <span class=n>cache</span>
<span class=o>...</span>
<span class=k>def</span> <span class=nf>jogos_por_edicao</span><span class=p>(</span><span class=n>edicao_slug</span><span class=p>):</span>
    <span class=n>jogos</span> <span class=o>=</span> <span class=n>cache</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;jogos_</span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=n>edicao_slug</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>jogos</span><span class=p>:</span>
        <span class=n>jogos</span> <span class=o>=</span> <span class=n>pega_jogos_da_semantica</span><span class=p>(</span><span class=n>edicao_slug</span><span class=p>)</span>
        <span class=n>cache</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;jogos_</span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=n>edicao_slug</span><span class=p>,</span> <span class=n>jogos</span><span class=p>)</span>
    <span class=o>...</span>
</pre></div> <p>Passamos ao <code>cache.set</code> uma chave (que deve ser menor que 250 caracteres, e não utilizar caracteres especiais) e um valor. Ele também aceita um terceiro parâmetro, que é o tempo de vida desta informação em <em>cache</em>. Quando omitido, o tempo definido nas configurações do <em>backend</em> é utilizado.</p> <p>Para remover esta informação do <em>cache</em>, basta utilizarmos o método <code>cache.delete</code>:</p> <div class=highlight><pre><span></span><span class=n>cache</span><span class=o>.</span><span class=n>delete</span><span class=p>(</span><span class=s1>&#39;jogos_</span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=n>edicao_slug</span><span class=p>)</span>
</pre></div> <p>Você tem a liberdade de fazer <em>caching</em> de qualquer região da sua aplicação. Mas é bom tomarmos cuidado para que o gerenciamento desses pontos não passem a ser um problema. O <em>framework</em> de <em>cache</em> pode ser aplicado em outras camadas da abstração, dispensando (em muitos casos) a necessidade desse tipo de controle em modelos e <em>views</em>.</p> <h3>Template</h3> <p>Assim como é possível fazer <em>caching</em> de forma minuciosa com a <em>API</em> acima, é possível fazer um controle muito interessante de <em>cache</em> com os <em>templates</em> do <em>Django</em>.</p> <h4>Prevenindo acesso a disco</h4> <p>A cada nova requisição, o <em>Django</em> carrega o arquivo de <em>template</em> do disco, interpreta-o com o contexto, e retorna o seu resultado. Podemos melhorar um pouquinho este fluxo, sem necessitar do <em>Memcached</em>, basta adicionarmos o <code>django.template.loaders.cached.Loader</code> ao <code>TEMPLATE_LOADERS</code> do <code>settings.py</code>:</p> <div class=highlight><pre><span></span><span class=n>TEMPLATE_LOADERS</span> <span class=o>=</span> <span class=p>(</span>
    <span class=p>(</span><span class=s1>&#39;django.template.loaders.cached.Loader&#39;</span><span class=p>,</span> <span class=p>(</span>
        <span class=s1>&#39;django.template.loaders.filesystem.Loader&#39;</span><span class=p>,</span>
        <span class=s1>&#39;django.template.loaders.app_directories.Loader&#39;</span><span class=p>,</span>
    <span class=p>)),</span>
<span class=p>)</span>
</pre></div> <p>Esse <em>loader</em> manterá o arquivo de <em>template</em> em memória, evitando com que o <em>Django</em> tenha que recorrer ao disco para obter o seu conteúdo. O “trade-off” é mais utilização da memória do seu servidor (que, dependendo do cenário, nem é um problema tão grande assim) e a necessidade de, quando houver atualizações em <em>templates</em>, efetuar o <em>restart</em> do serviço de <em>WSGI</em> que você utiliza.</p> <p>Outro ponto a se observar é que as <em>template tags</em> que você utilizar deverão ser <a href=https://docs.djangoproject.com/en/dev/howto/custom-template-tags/#template-tag-thread-safety title="Leia mais na documentação do Django"><em>thread-safe</em></a>.</p> <h4>Prevenindo parsing desnecessário</h4> <p>O <em>framework</em> de <em>cache</em> permite “cachear” fragmentos de um <em>template</em>. Essa modalidade de <em>cache</em> é bem interessante quando utilizamos filtros ou <em>tags</em> que executam operações que aumentam consideravelmente o tempo de interpretação do <em>template</em>.</p> <p>Na <a href=https://docs.djangoproject.com/en/1.4/topics/cache/#template-fragment-caching title="Template fragment caching">documentação</a> há um exemplo bem interessante, onde é feito o <em>cache</em> de um <em>sidebar</em> inteiro:</p> <div class=highlight><pre><span></span>{% load cache %}

{% cache 500 sidebar %}
    <span class=c>&lt;!-- conteúdo do sidebar --&gt;</span>
{% endcache %}
</pre></div> <p>Passamos para a <em>template tag</em> <code>cache</code> o tempo de vida do conteúdo (500 segundos), e o identificador deste conteúdo (<code>sidebar</code>). Se a chave não existir, o <em>Django</em> interpretará as instruções dentro do bloco e armazenará o seu resultado no <em>Memcached</em> para que, num próximo acesso, esse resultado seja recuperado sem necessitar interpretar todo o bloco novamente.</p> <h3>Views</h3> <p>Uma das maneiras mais práticas de utilizarmos o <em>cache</em> em nossos <em>websites</em> e aplicações <em>Web</em> escritos em <em>Django</em>, é através do método chamado <a href=https://docs.djangoproject.com/en/1.4/topics/cache/#the-per-site-cache title="Leia mais sobre na documentação do Django"><em>per-site cache</em></a>.</p> <p>Basicamente, o <em>Django</em> analisará requisições realizadas através dos métodos <code>GET</code> e <code>HEAD</code>, e utilizará a sua <em>URL</em> como chave para a verificação em <em>cache</em>. Caso ele encontre a ocorrência, retornará ao usuário o resultado “cacheado”, senão, interpretará a <em>view</em> e ao final armazenará o seu resultado.</p> <p>Para que isso seja possível, é necessário a utilização dos <em>middlewares</em> <code>django.middleware.cache.UpdateCacheMiddleware</code> e <code>django.middleware.cache.FetchFromCacheMiddleware</code>:</p> <div class=highlight><pre><span></span><span class=n>MIDDLEWARE_CLASSES</span> <span class=o>=</span> <span class=p>(</span>
    <span class=s1>&#39;django.middleware.cache.UpdateCacheMiddleware&#39;</span><span class=p>,</span>
    <span class=o>...</span>
    <span class=s1>&#39;django.middleware.cache.FetchFromCacheMiddleware&#39;</span><span class=p>,</span>
<span class=p>)</span>
</pre></div> <p>Além da configuração das seguintes constantes:</p> <ul> <li><code>CACHE_MIDDLEWARE_ALIAS</code> : O identificador da conexão (padrão <code>default</code>)</li> <li><code>CACHE_MIDDLEWARE_SECONDS</code> : O tempo de vida (em segundos) das páginas em <em>cache</em> (padrão <code>600 segundos</code>)</li> <li><code>CACHE_MIDDLEWARE_KEY_PREFIX</code> : Chave para prevenir problemas quando o <em>cache</em> é um serviço compartilhado entre diferentes instâncias <em>Django</em>. Pode-se, por exemplo, colocar o nome do <em>site</em> como prefixo.</li> </ul> <p>Ao acessar as <em>views</em>, temos uma agradável surpresa:</p> <div class=highlight><pre><span></span>$ curl -I http://localhost:8000/

HTTP/1.0 <span class=m>200</span> OK
Date: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:12:17 GMT
Server: WSGIServer/0.1 Python/2.7.2
Cache-Control: max-age<span class=o>=</span><span class=m>600</span>
Vary: Cookie
Expires: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:22:17 GMT
Content-Type: text/html<span class=p>;</span> <span class=nv>charset</span><span class=o>=</span>utf-8
Last-Modified: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:12:17 GMT
</pre></div> <p>Ganhamos <a href=https://klauslaube.com.br/2012/05/14/o-cache-e-o-http.html title="O cache e o HTTP">cabeçalhos <em>HTTP</em></a> com os valores correspondentes às nossas configurações de <em>cache</em>! Por exemplo, <code>Last-Modified</code> corresponde a data de acesso, <code>Expires</code> é a data de acesso acrescentando os 600 segundos de <em>cache</em>, e o <code>Expires</code> corresponde ao tempo de <code>CACHE_MIDDLEWARE_SECONDS</code>.</p> <p>Interessante não? Temos um controle de <em>cache</em> na “borda” da nossa aplicação… não precisamos interferir nas nossas <em>views</em>, modelos ou consultas.</p> <h4>O método per-view</h4> <p>É natural que certas <em>views</em> necessitem de um tempo de <em>cache</em> diferente de outras. Para tanto, podemos utilizar <em>decorators</em> que “sobrescrevem” as configurações utilizadas pelo <em>per-site</em>, permitindo assim um controle mais granular sobre o tempo de <em>cache</em> das <em>views</em>. Exemplo:</p> <div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>django.views.generic.simple</span> <span class=kn>import</span> <span class=n>direct_to_template</span>
<span class=kn>from</span> <span class=nn>django.views.decorators.cache</span> <span class=kn>import</span> <span class=n>cache_page</span>

<span class=n>urlpatterns</span> <span class=o>=</span> <span class=n>patterns</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=p>,</span>
    <span class=o>...</span>
    <span class=n>url</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;^outra-view/$&#39;</span><span class=p>,</span> <span class=n>cache_page</span><span class=p>(</span><span class=mi>60</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)(</span><span class=n>direct_to_template</span><span class=p>),</span>
        <span class=p>{</span><span class=s1>&#39;template&#39;</span><span class=p>:</span> <span class=s1>&#39;outra-view.html&#39;</span><span class=p>},</span> <span class=n>name</span><span class=o>=</span><span class=s1>&#39;outra-view&#39;</span><span class=p>),</span>
    <span class=o>...</span>
<span class=p>)</span>
</pre></div> <p>No exemplo acima estou usando a <em>generic view</em> <code>direct_to_template</code> para ilustrar. Através do <em>decorator</em> <code>cache_page</code> eu informo o tempo de vida desta <em>view</em> em <em>cache</em> (2 minutos, 60 * 2 para ficar mais legível).</p> <p>E quando acessamos esta <em>view</em>, é possível reparar que inclusive os valores dos cabeçalhos <em>HTTP</em> são outros:</p> <div class=highlight><pre><span></span>$ curl -I http://localhost:8000/outra-view/

HTTP/1.0 <span class=m>200</span> OK
Date: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:28:07 GMT
Server: WSGIServer/0.1 Python/2.7.2
Last-Modified: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:28:07 GMT
Expires: Wed, <span class=m>04</span> Jul <span class=m>2012</span> <span class=m>00</span>:30:07 GMT
Content-Type: text/html<span class=p>;</span> <span class=nv>charset</span><span class=o>=</span>utf-8
Vary: Cookie
Cache-Control: max-age<span class=o>=</span><span class=m>120</span>
</pre></div> <p>Ainda é possível passar como parâmetro para o <code>cache_page</code>, o <code>cache</code> que você deseja utilizar (por padrão <code>default</code>), e um <code>key_prefix</code>.</p> <h2>Caching de queries com o Johnny Cache</h2> <p>É normal que algumas rotas da sua aplicação não possam fazer utilização desse tipo de <em>cache</em>. Por exemplo, <em>views</em> para usuários autenticados, que necessitam transitar informações de sessão e <em>cookies</em>, ou até mesmo <em>views</em> que precisam receber informações através de <code>POST</code>.</p> <p>Vamos imaginar que, dentro desse cenário, a sua <em>app</em> faça uma consulta “custosa” ao banco de dados. Logo, concluímos que adicionar um controle de <em>cache</em> a esta consulta seria extremamente interessante para a velocidade de resposta da <em>view</em>. A primeira opção é utilizar o <em>framework</em> de <em>cache</em> do <em>Django</em> de forma granular, através de sua <em>API</em>. A outra opção é fazer <em>caching</em> “dentro” do <em>ORM</em>.</p> <p>É apoiado nessa última proposta que o <a href=http://packages.python.org/johnny-cache/ title="Conheça a ferramenta de caching, Johnny Cache"><em>Johnny Cache</em></a> se baseia: “cachear” dados transitados através do <em>ORM</em> do <em>Django</em>, não interferindo no código das <em>apps</em>.</p> <p>O <em>Johnny Cache</em> está no <a href=http://pypi.python.org/pypi title="the Python Package Index"><em>PyPi</em></a>, então basta um <code>pip install johnny-cache</code> para realizarmos a instalação. Para configurar, precisamos adicionar algumas informações ao <code>settings.py</code>:</p> <div class=highlight><pre><span></span><span class=n>MIDDLEWARE_CLASSES</span> <span class=o>=</span> <span class=p>(</span>
    <span class=s1>&#39;johnny.middleware.LocalStoreClearMiddleware&#39;</span><span class=p>,</span>
    <span class=s1>&#39;johnny.middleware.QueryCacheMiddleware&#39;</span><span class=p>,</span>
    <span class=o>...</span>
<span class=p>)</span>

<span class=n>CACHES</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>&#39;default&#39;</span> <span class=p>:</span> <span class=p>{</span>
        <span class=s1>&#39;BACKEND&#39;</span><span class=p>:</span> <span class=s1>&#39;johnny.backends.memcached.MemcachedCache&#39;</span><span class=p>,</span>
        <span class=s1>&#39;LOCATION&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;127.0.0.1:11211&#39;</span><span class=p>],</span>
        <span class=s1>&#39;JOHNNY_CACHE&#39;</span> <span class=bp>True</span><span class=p>,</span>
    <span class=p>)</span>
<span class=p>}</span>
</pre></div> <p>Onde:</p> <ul> <li><code>johnny.middleware.LocalStoreClearMiddleware:</code> O <em>Johnny</em> utiliza este <em>middleware</em> para gerenciar o <em>cache</em> de uma <a href=https://github.com/jmoiron/johnny-cache/blob/master/johnny/transaction.py title="Veja o uso dessa modalidade no módulo transaction.py">maneira "thread-safe"</a>. Ele basicamente limpa este objeto ao final de cada requisição.</li> <li><code>johnny.middleware.QueryCacheMiddleware:</code> É o <em>middleware</em> responsável pela “mágica” de <em>caching</em> no <em>ORM</em>.</li> </ul> <p>O <em>backend</em> <code>johnny.backends.memcached.MemcachedCache</code> é basicamente uma <a href=https://github.com/jmoiron/johnny-cache/blob/master/johnny/backends/memcached.py title="Veja o código-fonte">subclasse do <em>backend built-in</em> do <em>Django</em> para o <em>Memcached</em></a>, com a adição do seguinte comportamento: Se o <em>timeout</em> for setado como 0 (zero), o <em>cache</em> fica “infinito”.</p> <p>Com a opção <code>JOHNNY_CACHE</code> como <code>True</code>, estamos informando ao <em>Johnny</em> que este é o <em>pool</em> de <em>cache</em> que ele deve usar para <em>caching</em> das <em>queries</em>. É possível ter uma configuração diferenciada, como encontrada no <a href=https://github.com/nelas/cifonauta/blob/master/dummy_settings_server.py#L33 title="Veja o código-fonte do projeto no GitHub">projeto Cifonauta</a>.</p> <p>Com a ajuda do <a href=http://pypi.python.org/pypi/django-debug-toolbar/ title="Excelente lib para debugging de projetos Django">django-debug-toolbar</a>, podemos ver o número de <em>queries</em> diminuírem consideravelmente (fatalmente ocasionando um tempo de resposta menor). Quando um registro for adicionado, editado ou removido, o <em>Johnny Cache</em> remove as <em>queries</em> envolvendo determinada tabela do <em>cache</em>, permitindo assim uma nova “batida” no banco de dados (e um novo armazenamento dos resultados).</p> <h2>Considerações finais</h2> <p>Como <a href=https://klauslaube.com.br/2011/12/19/nginx-poderoso-rapido-facil.html title="Nginx: Poderoso, rápido e fácil">já mencionei</a>, gosto muito dos ensinamentos e experiências compartilhadas pelo pessoal da <a href=http://37signals.com/ title="Making collaboration productive and enjoyable for people every day"><em>37Signals</em></a>. Um deles é para nos preocuparmos com performance quando isto for realmente um problema.</p> <p>Logo, (<em>IMO</em>) não construa uma mega <a href=https://klauslaube.com.br/tag/infraestrutura.html title="Leia mais sobre infra">infraestrutura</a> para uma aplicação que atende 50 usuários por dia. Você está desperdiçando o seu tempo e linhas de código. Em contrapartida, qualquer esforço para melhorar a experiência do usuário, e para economizar recursos, <strong>é sempre bem-vinda</strong>.</p> <p>Vale sempre ressaltar que problemas de performance podem estar relacionados a qualidade do código produzido, e não necessariamente com o consumo da aplicação. Então, se a demanda está baixa e mesmo assim você tem tempos de resposta absurdamente altos, talvez seja a hora de “refatorar” o seu código.</p> <h2>Referências</h2> <ul> <li><a href=https://docs.djangoproject.com/en/1.4/topics/cache/ title="Leia tudo sobre o framework de cache do Django"><em>Django Documentation – Cache Framework</em></a></li> <li><a href=https://docs.djangoproject.com/en/dev/ref/templates/api/#loader-types title="Mais informações sobre os template loaders do Django"><em>Django Documentation – The Django template language: Loader types</em></a></li> <li><a href=http://packages.python.org/johnny-cache/ title="Mais informações sobre o uso do Johnny Cache"><em>Johnny Cache Documentation</em></a></li> <li><a href=http://www.jongales.com/blog/2012/02/16/make-django-keep-templates-in-memory/ title="Leia mais sobre o cached.Loader"><em>Jongales.com – Make Django keep templates in memory</em></a></li> </ul> </div> </span> <div class=Article-tags> <span class=Article-tagLabel>Tags:</span> <span itemprop=keywords> <a href=https://klauslaube.com.br/tag/desenvolvimento.html title="Leia mais sobre" class=Article-tagLink>desenvolvimento</a> <a href=https://klauslaube.com.br/tag/web.html title="Leia mais sobre" class=Article-tagLink>web</a> <a href=https://klauslaube.com.br/tag/python.html title="Leia mais sobre" class=Article-tagLink>python</a> <a href=https://klauslaube.com.br/tag/django.html title="Leia mais sobre" class=Article-tagLink>django</a> <a href=https://klauslaube.com.br/tag/memcached.html title="Leia mais sobre" class=Article-tagLink>memcached</a> <a href=https://klauslaube.com.br/tag/johnny-cache.html title="Leia mais sobre" class=Article-tagLink>johnny-cache</a> <a href=https://klauslaube.com.br/tag/cache.html title="Leia mais sobre" class=Article-tagLink>cache</a> </span> </div> <div class=Article-comments> <div id=disqus_thread></div> <script type=text/javascript>
        var disqus_shortname = "klauslaube";
        var disqus_identifier = "2012/07/22/django-e-cache-uma-dupla-de-alta-performance-2.html";

        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </div> </article> </div> <footer class="PageFooter pure-u-1"> <div class=u-box> <p>O conteúdo deste blog está sob a licença <a class=PageFooter-link href=http://creativecommons.org/licenses/by/3.0/deed.pt_BR title="Distribua, adapte, use. Mas mencione o autor." rel=nofollow>Creative Commons Attribution 3.0</a>.</p> <p>O código está disponível em <a class=PageFooter-link href=https://github.com/kplaube/blog/ title=Contribute! rel=nofollow>GitHub</a>.</p> </div> </footer> </div> <script>
        (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[0];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-19657400-1');ga('send','pageview');
    </script> </body> </html>