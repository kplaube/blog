<!DOCTYPE html><html lang=pt-br> <head><meta charset=utf-8><title>Vivendo sem o Grunt | Klaus Laube</title><meta name=author content="Klaus Peter Laube"><meta name=description content="No meu primeiro contato com o Grunt, ele não me convenceu. Foi ao trabalhar com Single Page Applications que a ferramenta me conquistou. Hoje, com Browserify e PostCSS fica a dúvida: Talvez você não precise do Grunt."><meta name=robots content=index,follow><meta property=og:site_name content="Klaus Laube"><meta property=og:type content=website><meta name=keywords content="desenvolvimento, web, javascript, node, npm, grunt"><meta property=og:title content="Vivendo sem o Grunt"><meta property=og:description content="No meu primeiro contato com o Grunt, ele não me convenceu. Foi ao trabalhar com Single Page Applications que a ferramenta me conquistou. Hoje, com Browserify e PostCSS fica a dúvida: Talvez você não precise do Grunt."><meta property=og:url content=https://klauslaube.com.br/2016/02/22/vivendo-sem-o-grunt.html><meta property=og:image content=https://klauslaube.com.br//images/blog/king-baratheon.jpg><meta property=fb:app_id content=262757647133878><meta name=google-site-verification content=xCq0H3B3JhkPcAdZ03J0vayijvH_g1rQVMZ_DVcMsQY><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=icon type=image/x-icon href=https://klauslaube.com.br/favicon.ico><link rel=alternate type=application/rss+xml title="Klaus Laube » Feed" href=https://klauslaube.com.br/feed/rss.xml><link rel=canonical href=https://klauslaube.com.br/2016/02/22/vivendo-sem-o-grunt.html><link rel=stylesheet href=https://unpkg.com/purecss@1.0.0/build/pure-min.css integrity=sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w crossorigin=anonymous><link rel=stylesheet href=https://klauslaube.com.br/theme/css/styles.min.css?0830b1e2></head> <body> <div class="Page pure-g is-fullEntry"> <div class="PageHeader pure-u-1"> <nav class="pure-menu pure-menu-open pure-menu-horizontal"> <a href=https://klauslaube.com.br/index.html title="Home page" class="PageHeader-link pure-menu-heading pure-menu-link">Klaus<span class=u-highlighted>Laube</a> <ul class="PageHeader-menu pure-menu-list"> <li class=pure-menu-item> <a href=https://about.me/klauslaube class="PageHeader-menu-link pure-menu-link">Contato</a> </li> </ul> </nav> </div> <div class="PageContent pure-u-1"> <article class="Article u-box" itemscope itemtype=http://schema.org/BlogPosting> <div itemprop=image itemscope itemtype=http://schema.org/ImageObject> <meta itemprop=url content=https://klauslaube.com.br//images/blog/king-baratheon.jpg> </div> <span itemprop=mainEntityOfPage> <header> <h1 class=Article-title itemprop="headline name"> Vivendo sem o Grunt </h1> <p class=Article-meta> Por <span class=Article-author itemprop=author>Klaus Peter Laube</span>. <span class=Article-pubDate> Publicado em <time datetime=2016-02-22T12:35:00-03:00 itemprop=datePublished>22 Fev, 2016</time> </span> </p> </header> <div class=Article-content itemprop=articleBody> <img src=/images/blog/grunt-logo.png alt="Logotipo do Grunt" class=representative-image width=180 height=180> <p>No meu primeiro contato com o <em>Grunt</em>, ele não me convenceu. Qual era a necessidade de um <em>task runner</em> se eu já tinha o <code>Makefile</code>? O mesmo valia para o <em>build</em> de estáticos... <em>Frameworks</em> como o <em>Django</em> já possuíam um <em>pipeline</em> de concatenação e minificação, não sendo necessário que um processo externo interferisse em algo que (até então) funcionava muito bem.</p> <!-- PELICAN_END_SUMMARY --> <p>Foi ao trabalhar com <em>Single Page Applications</em> que o <em>Grunt</em> me conquistou. Coisas que iam da otimização de imagens a deploy para ambientes passaram a ser responsabilidade da ferramenta, e a partir desse momento eu a carreguei para todo projeto que participei.</p> <p>Mas o <em>Grunt</em> não é "bala de prata". Se para determinados problemas ele funciona muito bem, para outros ele representa um "peso" questionável na sua <em>stack</em>. Aumentando tempo de desenvolvimento (alguém aí já sofreu com o <code>grunt-contrib-watch</code>?), <em>build</em> e <em>setup</em> do seu ambiente.</p> <p>É baseado nesse contexto que <a href="https://www.google.com.br/search?q=stop%20using%20grunt&oq=stop%20using%20grunt&aqs=chrome..69i57j0l5.1498j0j7&sourceid=chrome&es_sm=91&ie=UTF-8" title="Stop using Grunt">faço coro com alguns <em>developers</em> espalhados por aí</a>: Talvez o seu projeto não precise do <em>Grunt</em>.</p> <h2>O que há de errado com o ele?</h2> <p><strong>Nada!</strong></p> <p><em>Grunt</em>, <em>Gulp</em>, <em>Brocolli</em>, <em>Brunch</em>, etc. são ferramentas super bacanas que cumprem com louvor o seu objetivo. Só que assim como o <em>jQuery</em>, para determinados casos elas podem ser "too much".</p> <p>Assim como há uma frente defendendo o <a href=http://www.codemag.com/article/1501101 title="Why Micro JavaScript Library Should Be Used in Your Next Application">uso de <em>microlibs</em></a> ao invés de <em>fat frameworks</em>, há uma frente defendendo o uso do <a href=http://www.sitepoint.com/guide-to-npm-as-a-build-tool/ title="Give Grunt the Boot! A Guide to Using npm as a Build Tool"><em>NPM</em> como ferramenta de <em>build</em></a>. E por mais que possa parecer "<a href="https://www.youtube.com/watch?v=tSUtPkJhvOU" title="Chora mais">mimimi</a>", alguns argumentos fazem certo sentido. Como por exemplo, o do <em>Keith Cirkel</em> no "<a href=http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/ title="Você deveria parar de usar Grunt">Why we should stop using Grunt &amp; Gulp</a>":</p> <blockquote> <p>None of these build tools work without plugins. Just found an awesome new tool which will revolutionise your build process? Great! Now just wait for someone to write a wrapper for Grunt/Gulp/Brocolli, or write it yourself. Rather than just learning the command line for the tool you want to use, you now have to learn its programatic API, plus the API for your build tool.</p> </blockquote> <p><em>Flamewars</em> e "discursos de ódio" à parte, a pergunta que fica é: Será que é tão difícil assim montar um <em>pipeline</em> de <em>build</em> sem o uso de <em>Grunt</em> e <em>Gulp</em>?</p> <p><img class=align-center src=/images/blog/king-baratheon.jpg width=610 height=411 title="Nem todo mundo gosta de Javalis (br.ign.com)" alt="Nem todo mundo gosta de Javalis (br.ign.com)"></p> <p>Ter uma ferramenta a menos na <em>stack</em> do projeto pode tornar-ser um diferencial ao reduzir atrito e curva de aprendizado. Mas tirar o <em>Grunt</em> da jogada não significa necessariamente ter menos complexidade no seu projeto... Apenas significa fazer a mesma coisa com uma dependência a menos.</p> <h2>NPM como ferramenta de build</h2> <p>O <em><a href=https://www.npmjs.com/package/livereload title="LiveReload server">Livereload</a></em> é uma biblioteca escrita em <em>Node</em> que levanta um servidor que monitora alterações no seu projeto e promove um <em>refresh</em> no navegador <em>web</em>.</p> <p>Podemos executá-lo através da linha de comando:</p> <div class=highlight><pre><span></span>$ livereload meuprojeto/static/css
</pre></div> <p>É possível usar o <code>package.json</code> como um "centralizador" de operações, assim como fazemos com o nosso <code>Makefile</code>:</p> <div class=highlight><pre><span></span>$ npm run livereload
</pre></div> <p>Para tanto, no arquivo <code>package.json</code>, precisamos adicionar a chave <code>scripts</code> com as instruções de execução para o comando <code>livereload</code>:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=p>...</span>
<span class=s2>&quot;scripts&quot;</span><span class=o>:</span> <span class=p>{</span>
  <span class=s2>&quot;livereload&quot;</span><span class=o>:</span> <span class=s2>&quot;livereload meuprojeto/static/css&quot;</span>
<span class=p>}</span>
<span class=p>...</span>
</pre></div> <p>Talvez haja a necessidade da execução de um comando mais complexo. Para isso, podemos utilizar um <em>script</em> <em>Node</em> como ajuda:</p> <div class=highlight><pre><span></span><span class=c1>// build/livereload.js</span>

<span class=kd>var</span> <span class=nx>livereload</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;livereload&#39;</span><span class=p>);</span>

<span class=kd>var</span> <span class=nx>PATH_CSS</span> <span class=o>=</span> <span class=s1>&#39;meuprojeto/build/static/css&#39;</span><span class=p>;</span>
<span class=kd>var</span> <span class=nx>PATH_JS</span> <span class=o>=</span> <span class=s1>&#39;meuprojeto/build/static/js&#39;</span><span class=p>;</span>

<span class=kd>var</span> <span class=nx>server</span> <span class=o>=</span> <span class=nx>livereload</span><span class=p>.</span><span class=nx>createServer</span><span class=p>();</span>
<span class=nx>server</span><span class=p>.</span><span class=nx>watch</span><span class=p>([</span><span class=nx>PATH_CSS</span><span class=p>,</span> <span class=nx>PATH_JS</span><span class=p>]);</span>
</pre></div> <p>E o nosso arquivo de configuração ficaria assim:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=p>...</span>
<span class=s2>&quot;scripts&quot;</span><span class=o>:</span> <span class=p>{</span>
  <span class=s2>&quot;livereload&quot;</span><span class=o>:</span> <span class=s2>&quot;node buid/livereload&quot;</span>
<span class=p>}</span>
<span class=p>...</span>
</pre></div> <p>Vale lembrar que o <code>npm</code> já possui alguns comandos padrões, que não necessitam da instrução <code>run</code>. Por exemplo, temos a execução de testes através do comando <code>npm test</code>.</p> <h3>Um exemplo mais complexo</h3> <p>O exemplo acima é simples e questionável. Vamos partir de uma necessidade mais palpável e complexa: Quero compilar componentes escritos em <em>React</em> e <em>ES6</em>.</p> <p>Para ilustrar, usaremos as bibliotecas <em><a href=https://facebook.github.io/react/ title="A Javascript library for building UI">React</a></em>, <em><a href=https://github.com/babel/babelify title="Browserify transform for Babel">Babelify</a></em> e <em><a href=https://github.com/mishoo/UglifyJS2 title="JavaScript parser / mangler / compressor / beautifier toolkit">UglifyJS</a></em>:</p> <div class=highlight><pre><span></span>$ npm install react --save
$ npm install babelify babel-preset-react babel-preset-es2015 uglify-js --save-dev
</pre></div> <p>Podemos criar dois comandos diferentes na nossa chave <code>scripts</code>, um para <em>transpiling</em> de <em>Javascript</em> e outro para minificação:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=s2>&quot;compile-js&quot;</span><span class=o>:</span> <span class=s2>&quot;browserify meuprojeto/js/script.js -o meuprojeto/build/static/js/bundle.js -t [ babelify --presets [ es2015 react ] ]&quot;</span><span class=p>,</span>

<span class=s2>&quot;minify-js&quot;</span><span class=o>:</span> <span class=s2>&quot;uglifyjs meuprojeto/build/static/js/bundle.js -o meuprojeto/build/static/js/bundle.min.js&quot;</span>
</pre></div> <p>Grande demais? É possível isolar esses comandos em <em>scripts</em>, como no exemplo do <em>livereload</em>:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=s2>&quot;compile-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/compile-js&quot;</span><span class=p>,</span>
<span class=s2>&quot;minify-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/minify-js&quot;</span>
</pre></div> <p>Para tornar mais simples a execução, vamos criar uma <em>task</em> genérica de <em>build</em>:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=s2>&quot;compile-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/compile-js&quot;</span><span class=p>,</span>
<span class=s2>&quot;minify-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/minify-js&quot;</span><span class=p>,</span>
<span class=s2>&quot;build&quot;</span><span class=o>:</span> <span class=s2>&quot;npm run compile-js &amp;&amp; npm run minify-js&quot;</span>
</pre></div> <p>Com uma ajudinha da <em>lib</em> <em><a href=https://www.npmjs.com/package/watch title="Utilities for watching file trees">Watch</a></em>, podemos incrementar ainda mais o nosso processo:</p> <div class=highlight><pre><span></span><span class=c1>// package.json</span>

<span class=p>...</span>
<span class=s2>&quot;scripts&quot;</span><span class=o>:</span> <span class=p>{</span>
  <span class=s2>&quot;compile-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/compile-js&quot;</span><span class=p>,</span>
  <span class=s2>&quot;minify-js&quot;</span><span class=o>:</span> <span class=s2>&quot;node build/minify-js&quot;</span><span class=p>,</span>
  <span class=s2>&quot;build&quot;</span><span class=o>:</span> <span class=s2>&quot;npm run compile-js &amp;&amp; npm run minify-js&quot;</span><span class=p>,</span>
  <span class=s2>&quot;watch&quot;</span><span class=o>:</span> <span class=s2>&quot;watch &#39;npm run build&#39; meuprojeto/static/js&quot;</span>
<span class=p>}</span>
<span class=p>...</span>
</pre></div> <p>Pronto! Agora temos os comandos <code>npm run build</code> e <code>npm run watch</code> que nos ajudarão na demanda de "transpilar" e minificar componentes escritos em <em>React</em>.</p> <p>Não foi tããããão difícil assim... Certo? Bastou abrir a documentação de cada ferramenta e perder alguns minutinhos lendo.</p> <p>"Mas você teve que escrever mais linhas que escreveria utilizando um <em>plugin</em> do <em>Grunt</em>."</p> <p>Possivelmente. Bem como é possível que eu nunca mais vá mexer nessas linhas escritas, uma vez que o processo já esteja montado e operacional.</p> <h2>Considerações finais</h2> <p>O mérito dos exemplos acima não está necessariamente na utilização do <code>npm</code> como ferramenta de <em>build</em>, mas sim nos incríveis pacotes que a comunidade <em>Javascript</em> tem construído para agilizar a construção de aplicações.</p> <p>Ferramentas como o <em>Grunt</em>, em seu tempo, fizeram uma revolução no que tange o desenvolvimento de aplicações <em>web</em> (e não há dúvida que ainda o fazem). Mas com o advento do <em>webpack</em>, <em>Browserify</em> e <em>PostCSS</em>, o seu uso passou de essencial para opcional.</p> <p>Até a próxima.</p> <h2>Referências</h2> <ul> <li><a href=https://addyosmani.com/blog/prosconsmicroframeworks/ >Addy Osmani: The Pros And Cons Of JavaScript Micro-Frameworks</a></li> <li><a href=http://engineering.hobsons.com/2015/06/26/build-tools-vs-npm-scripts-why-not-both/ >Hobsons Engineering: Build Tools vs npm Scripts: Why Not Both?</a></li> <li><a href=https://medium.com/@dabit3/introduction-to-using-npm-as-a-build-tool-b41076f488b0#.hc5o17p1p>Nader Dabit: Introduction to Using NPM as a Build Tool</a></li> <li><a href=https://medium.com/@nickheiner/maybe-you-should-stop-using-grunt-40ac57fd6ad9#.cpc7pdvwr>Nick Heiner: Maybe you should stop using Grunt</a></li> <li><a href=http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/ >Keith Cirkel: Why we should stop using Grunt &amp; Gulp</a></li> <li><a href=http://lucasmreis.github.io/blog/npm-is-an-amazing-build-tool/ >Lucas M Reis: NPM is an amazing build tool (And solves 90% of the build issues)</a></li> <li><a href=http://www.sitepoint.com/guide-to-npm-as-a-build-tool/ >Sitepoint: Give Grunt the Boot! A Guide to Using npm as a Build Tool</a></li> <li><a href=http://stackoverflow.com/questions/28503800/grunt-is-extremely-slow-100-cpu>Stackoverflow: Grunt is extremely slow - 100% CPU</a></li> <li><a href=http://stackoverflow.com/questions/29244671/less-compiling-slow-with-grunt>Stackoverflow: Less compiling slow with Grunt</a></li> </ul> </div> </span> <div class=Article-tags> <span class=Article-tagLabel>Tags:</span> <span itemprop=keywords> <a href=https://klauslaube.com.br/tag/desenvolvimento.html title="Leia mais sobre" class=Article-tagLink>desenvolvimento</a> <a href=https://klauslaube.com.br/tag/web.html title="Leia mais sobre" class=Article-tagLink>web</a> <a href=https://klauslaube.com.br/tag/javascript.html title="Leia mais sobre" class=Article-tagLink>javascript</a> <a href=https://klauslaube.com.br/tag/node.html title="Leia mais sobre" class=Article-tagLink>node</a> <a href=https://klauslaube.com.br/tag/npm.html title="Leia mais sobre" class=Article-tagLink>npm</a> <a href=https://klauslaube.com.br/tag/grunt.html title="Leia mais sobre" class=Article-tagLink>grunt</a> </span> </div> <div class=Article-comments> <div id=disqus_thread></div> <script type=text/javascript>
        var disqus_shortname = "klauslaube";
        var disqus_identifier = "2016/02/22/vivendo-sem-o-grunt.html";

        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script> <noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript> </div> </article> </div> <footer class="PageFooter pure-u-1"> <div class=u-box> <p>O conteúdo deste blog está sob a licença <a class=PageFooter-link href=http://creativecommons.org/licenses/by/3.0/deed.pt_BR title="Distribua, adapte, use. Mas mencione o autor." rel=nofollow>Creative Commons Attribution 3.0</a>.</p> <p>O código está disponível em <a class=PageFooter-link href=https://github.com/kplaube/blog/ title=Contribute! rel=nofollow>GitHub</a>.</p> </div> </footer> </div> <script>
        (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[0];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-19657400-1');ga('send','pageview');
    </script> </body> </html>